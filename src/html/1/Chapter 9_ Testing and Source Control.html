			<h1>Testing and Source Control</h1> 
			<p>The success of our application depends on many factors, beyond the  quality of our code organization or patterns. Moreover, the very nature  of software implies that there will be changes during and after  development, changes in the requirements, the scope, and so on. With  each feature developed, an item of complexity is introduced into the  software, creating relationships and dependencies. New inclusions may  disrupt these connections and introduce breaking changes, bugs, or even  completely disable the system. The solution for this problem is to keep  track of code changes and conduct tests on the application to identify  problems and ensure as much as possible that the system complies with  the desired software attributes and satisfies the requirements.</p> 
			<p>In this chapter, we will cover the following:</p> 
			<ul> 
				<li>Different approaches to testing and the concept of <strong class="bold">test-driven </strong><strong class="bold">development (TDD)</strong></li> 
				<li>Installing a test suite (Vitest) and test tools (Vue Test Utils) for our project</li> 
				<li>Creating and running tests on an existing project for synchronous and asynchronous code</li> 
				<li>Testing our components by simulating user interactions</li> 
				<li>Installing and managing our source code using Git and online repositories such as GitHub or GitLab</li> 
			</ul> 
			<p>The concepts in this chapter are introductions to important  professional skills for a developer to ensure the delivery of  good-quality software. Often, these tasks are left aside or relegated as  an afterthought. However, the lack of them may lead to expensive  mistakes and lengthy overwork as the software complexity grows. For  non-trivial applications with more than one developer involved, nowadays, 
it is hardly possible to conceive a project that does not use some of these tools.</p> 
			<p>In this chapter, we will focus on <strong class="bold">unit testing</strong> and the tools provided by the Vue team to perform it.</p> 
			<h1>Technical requirements</h1> 
			<p>This chapter does not have additional requirements to those of  previous implementations of code examples. The final source code can be  found in the official repository for this book at <a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter09">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter09</a>.</p> 
			<p>Check out the following video to see the Code in Action: <a href="https://packt.link/UqRIi">https://packt.link/UqRIi</a></p> 
			<h1>What are testing and TDD</h1> 
			<p>Testing is the process to verify  that the software is doing what it is supposed to do, according to the  requirements of the project. It involves the manual or automated  execution of tools to evaluate and measure different properties and  attributes of the software, identify errors and bugs, and provide  feedback for developers to take action to correct them. There are many  different approaches and types of tests to be performed, such as the following:</p> 
			<ul> 
				<li><strong class="bold">Unit testing</strong>: This is where relevant units of the source code are validated against a series of inputs and outputs. It is often automated.</li> 
				<li><strong class="bold">Integration testing</strong>: All the components of a system are verified together as a group, looking for errors and bugs in the resulting integration, communication, and so on.</li> 
				<li><strong class="bold">End-to-end testing</strong>: This involves a complete validation of the application  simulating real-world use, interacting with databases, network  scenarios, and so on. It can be performed with automated tools that  simulate human interaction, and manual testing using real-life users.</li> 
			</ul> 
			<p>These types of testing are just a small sample of this discipline,  as there are hundreds of possible tests to apply to the software. Large  companies may have entire testing teams dedicated to ensuring the  quality of the software. Usually, the more complex the software, the  more complex the testing may be. In practice, the testing plan can be as  complex as the development plan itself. As mentioned in the  introduction, we will focus on the official tools provided by the Vue  team for this task.</p> 
			<p>Testing can be done before, during, after, or in parallel with the development. <strong class="bold">TDD</strong> is a discipline  that places the burden of testing as early in the project as possible,  even before the actual coding begins, with the objective to match the  requirements. It involves the following steps:</p> 
			<ol> 
				<li>Write a test case, based on the requirements and design of the application, with key inputs and expected outputs.</li> 
				<li>Run the test, which should fail (as there is no code written yet).</li> 
				<li>Write the actual code to be tested (a function, Vue component, etc.).</li> 
				<li>Run the test against the created code. If it fails, refactor the code or design.</li> 
				<li>Start again with a new test case for the next unit.</li> 
			</ol> 
			<p>This process is repeated, and it is expected to provide developers  with a significant reduction of “bugs” and errors and help them focus  on the requirements. This does incur an overhead of effort early in the  project, as opposed to refactoring, when the tests are performed toward the end.</p> 
			<p>TDD has become popular in some teams  and with some frameworks, and it is supposed to help developers improve  their own code as they now acquire a “testing” mindset. However, there  are no specific studies made to confirm this, but practitioners of this  discipline do report that it has improved their code and design. This,  of course, begs the question: what needs to be tested, and how can we  streamline the task into our workflow? That is the topic we will discuss next.</p> 
			<h1>What to test</h1> 
			<p>A key factor in the success of a  good testing plan and implementation is deciding what to test. It is not  possible to test the full universe of possibilities or 100% of the  components and interactions in a project when considering internal and  external factors. Even the attempt to fully cover all possibilities  would be incredibly expensive and practically impossible. Instead, the  focus needs to be on the real possibilities of what can be tested within  our time and budget constraints, by carefully selecting the non-trivial  elements that “make or break” our project requirements. This is often  not an easy task.</p> 
			<p>When it comes to Vue applications, we need to focus on crucial services and components that perform key operations. We need to test the following:</p> 
			<ul> 
				<li><strong class="bold">Services</strong>: Self-contained  functions, both synchronous and asynchronous. Functions that don’t  return a value but perform logical procedures will serve a different  kind of testing than what we will see here. These will involve mocking  network communications or database calls, application policies, and so  on. However, the principles for testing these are similar.</li> 
				<li><strong class="bold">Components</strong>: We need to  test inputs (props) and outputs (events and HTML). Higher-level  components that group other components to perform a workflow or business  logic can also be tested in the same way (props, events, and HTML  rendered). However, these also will need other types of testing, such as  end-to-end testing.</li> 
			</ul> 
			<p>We can write our own functions and tools to perform tests, but  apart from some edge cases, the obvious recommendation is to use stable  test suites and tools. In our case, for Vue, there are official  resources provided by the same team, called <strong class="bold">Vitest</strong> and <strong class="bold">Vue Test Utils</strong>. Using a  testing suite/library has many benefits, akin to the use of a framework  or library in the “regular” development of an application. Perhaps one  of the major benefits has to do with <strong class="bold">DX</strong>, or <strong class="bold">Developer eXperience</strong>, as they streamline  and make the development process easier or lighter in the best case.  Let’s learn how to apply these tools in our workflow by going through an  example application, which we will address in the next section.</p> 
			<h1>Our base example application</h1> 
			<p>It is best to understand the  discipline of testing and learn about the tools by applying them to a  real project through practice. As a learning exercise, we will first  take a running application based on one of the examples presented in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_02.xhtml#_idTextAnchor040"><em class="italic">Chapter 2</em></a>, <em class="italic">Software Design Principles and Patterns</em>. We will build a <strong class="bold">Fibonacci calculator</strong>  and install the Vitest test suite and Vue Testing Utils to the project.  Later, we will explain what would change in this approach when applying  the TDD discipline.</p> 
			<p>The code for this application can be found in the repository for this chapter. Once downloaded, 
you need to execute the following command to install the dependencies:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ npm install
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>Then, to run the application, you must run the following:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ npm run start
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>When the server is ready, loading the site in your web browser should present you with an application like this:</p> 
			<div> 
				<div class="IMG---Figure"> 
					<img src="Chapter%2099%20Testing%20and%20Source%20Control%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_9.01_B18602.jpg" alt="Figure 9.1 – The example application with a Fibonacci calculator" width="1331" height="231"> 
				</div> 
			</div> 
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The example application with a Fibonacci calculator</p> 
			<p>The design of this application has been made with the purpose of  learning the basics of testing functions and components, so it is very  basic but sufficient. We are presented with one service file (<strong class="source-inline">/src/services/Fibonacci.js</strong>) and three components: <strong class="source-inline">App.vue</strong>, <strong class="source-inline">FibonacciInput.vue</strong>, and <strong class="source-inline">FibonacciOutput.vue</strong>.</p> 
			<div> 
				<div class="IMG---Figure"> 
					<img src="Chapter%2099%20Testing%20and%20Source%20Control%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_9.02_B18602.jpg" alt="Figure 9.2 – Components and service for the application" width="640" height="206"> 
				</div> 
			</div> 
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Components and service for the application</p> 
			<p>Our application-level component, <strong class="source-inline">App.vue</strong>, receives from <strong class="source-inline">FibonacciInput.vue</strong> a positive integer number through an event, which passes as a prop input to <strong class="source-inline">FibonacciOutput.vue</strong>. This component uses the <strong class="source-inline">Fibonacci.js</strong>  service to calculate the respective Fibonacci number corresponding in  the series and present it to the user. As simple as this application  sounds, it gives us basic examples to create tests for the most common cases, which will give us a solid start. It is now time to install our test suite.</p> 
			<h1>Installation and use of Vitest</h1> 
			<p><strong class="bold">Vitest</strong> (<a href="https://vitest.dev/">https://vitest.dev/</a>) is a test suite, meaning that it provides, out of the box, a set of tools and a  framework to perform tests in our code. Being developed by the Vue and  Vite teams, it integrates seamlessly with Vite, even sharing the same  configuration and respecting each other’s organization. <em class="italic">Vitest </em>can  be selected during the original creation of a Vue project by selecting  the proper option during the creation wizard – a task that will add a <strong class="source-inline">/src/__tests__</strong> folder, some examples, and a few extra entries in our <strong class="source-inline">package.json</strong> file. But all this boilerplate can be a bit confusing unless  we have previous experience in this area. Instead, we start from an  already created project, so we will install Vitest as a development  dependency – a task that will give us an insight into how it works and is organized.</p> 
			<p>Install Vitest from the command line at the root directory of the project with this command:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ npm install -D vitest
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>The package manager will take some time to include Vitest and all  necessary dependencies but won’t modify our source code or organization.  For convenience, we will use <strong class="source-inline">npm</strong> as well to run our tests, so we need to open our <strong class="source-inline">package.json</strong> file, and in the <strong class="source-inline">scripts</strong> section, enter the following lines so the section looks like this:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="source-code"> 
"scripts": { 
&nbsp;&nbsp;&nbsp;&nbsp;"start":"vite", 
&nbsp;&nbsp;&nbsp;&nbsp;"build": "vite build", 
&nbsp;&nbsp;&nbsp;&nbsp;"preview": "vite preview", 
<strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;"test": "vitest",</strong> 
<strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;"test:once": "vitest run",</strong> 
<strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;"test:coverage": "vitest run --coverage"</strong> 
}
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>At this point, we can now test our test suite:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ npm run test
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>After you run that command, you will  be graciously greeted with a red message explaining that the tests have  failed. Perfect. This is what it should do, as we do not have any tests  yet! So, let’s add them. We will start by testing our <strong class="source-inline">Fibonacci.js</strong> service.</p> 
			<p>Vitest allows us to write our test functions in independent files  or in-source, meaning that we place them alongside our component’s  JavaScript. There are benefits and trade-offs with both approaches, but  to start, we will place our test code in independent files, one for each  service and component. In this way, we place these files in their own  directory, which by convention can be either <strong class="source-inline">/src/tests</strong> or <strong class="source-inline">/src/components/__tests__</strong>,  but they could also be placed alongside the Single File Components or  with the services. Vitest will scan the entire source folder for the  test files. Even though we can be very creative when placing these  files, we will place them in <strong class="source-inline">/src/test</strong>  to keep things neat and tidy. There is another convention to adhere to,  which is that each test file must have the same name as the file being  tested, plus the <strong class="source-inline">.spec.js</strong> or <strong class="source-inline">.test.js</strong> extension. Vitest uses this convention to identify and run the tests in an organized manner. So, in our case, our <strong class="source-inline">Fibonacci.js</strong> service will have its testing counterpart in <strong class="source-inline">/src/tests/Fibonacci.test.js</strong>. Go ahead and create that file, and enter the following lines:</p> 
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/tests/Fibonacci.test.js</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="source-code"> 
import { <strong class="bold">describe, expect, test</strong> } from "vitest" 
import { Fibonacci, FibonacciPromise } from "../services/Fibonacci.js"
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>In the first line, we import three  functions from Vitest, which are the foundation of all our testing, and  the ones that we will be using most often. Here is what each one does:</p> 
			<ul> 
				<li><strong class="source-inline">describe(String, Function)</strong>:  This function groups together a number of tests, and Vitest will report  the test group by using the description given as the first parameter.  The second parameter is a function, where we will run the tests with the  <strong class="source-inline">test()</strong> function.</li> 
				<li><strong class="source-inline">test(String, Function)</strong>:  The first parameter is a description of the tests encompassed in the  second parameter, which is a function. The test will “pass” if no errors  are thrown within it. This means that we can write our own test logic  and tools following this condition and throw a JavaScript error when the  validation fails. However, there is a simpler approach...</li> 
				<li><strong class="source-inline">expect(value)</strong>: This is  the function that performs the “magic” of testing. It receives, as a  unique argument, a single value or a function that resolves to a single  value. The result of <strong class="source-inline">expect()</strong> is a  chainable object that exposes many different and almost  language-natural assertions (comparisons, validations, etc.) to perform  on the argument value. Under the hood, it uses the Chia syntax to a  certain extent and is also compatible with other test suites, such as  Jest – for example, <strong class="source-inline">expect(2).toBe(2)</strong>. A full list of all the possible assertion methods can be found in the official documentation here: <a href="https://vitest.dev/api/expect.html">https://vitest.dev/api/expect.html</a>.</li> 
			</ul> 
			<p>In the second line of the test file, we directly import the two functions contained in the service: <strong class="source-inline">Fibonacci()</strong> and <strong class="source-inline">FibonacciPromise()</strong>.  We need to import each function that we want to test, and then create  as many test groups as necessary for each one. Let’s start with the  self-contained <strong class="source-inline">Fibonacci()</strong> function by adding the following test group:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="source-code"> 
<strong class="bold">describe</strong>("Test the results from Fibonacci()", () =&gt; { 
 <strong class="bold">test</strong>("Results according to the series definition", ()=&gt;{ 
&nbsp;&nbsp;&nbsp;&nbsp;// Expected values as defined by the series 
&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">expect(</strong>Fibonacci(0)<strong class="bold">).toBe(0)</strong> 
&nbsp;&nbsp;&nbsp;&nbsp;expect(Fibonacci(1)).toBe(1) 
&nbsp;&nbsp;&nbsp;&nbsp;expect(Fibonacci(2)).toBe(1) 
&nbsp;&nbsp;&nbsp;&nbsp;expect(Fibonacci(3)).toBe(2) 
&nbsp;&nbsp;&nbsp;&nbsp;// A known value defined by calculation of the series 
&nbsp;&nbsp;&nbsp;&nbsp;expect(Fibonacci(10)).toBe(55) 
 }) 
})
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>We start by creating a test group with <strong class="source-inline">describe()</strong> and create inside the passed function as many tests as needed. Inside each <strong class="source-inline">test()</strong>  function, we can create as many assertions as needed, but it has to  have at least one. Notice how we are executing the function from the  service with different arguments, and then asserting them to the  expected value as defined in the numerical series. In this case, we are  using <strong class="source-inline">.toBe() </strong>to test equality, but in the same way, we could be testing strings, objects, types, and so on, using other assertions, such as <strong class="source-inline">.not, .toEqual, .toBeGreaterThan</strong>, etc. There are more than 50 assertion methods defined in the documentation (<a href="https://vitest.dev/api/expect.html">https://vitest.dev/api/expect.html</a>). Take some time to review them, and remember that these are chainable, so you can make more than one assertion at once.</p> 
			<p>After saving this file, you can run the test again:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ npm run test
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>You should receive a few messages in green, indicating the number  of tests performed and whether they passed or not. In the case that one  raises an error, it will be pointed out in red letters using the  descriptive text and line where it occurred. That is a sign to start  refactoring the code (assuming the test function and assertion were  properly and correctly written; otherwise, you get a false positive!).</p> 
			<p>In the case that no assertion method works for a particular edge case, you can create inside <strong class="source-inline">test()</strong> your own logic in plain JavaScript and throw an error when the validation fails. For example, these two code snippets are equivalent:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="source-code"> 
// Using expect 
expect(Fibonacci(10)).toBe(55); 
// Using your own logic 
let result=Fibonacci(10); 
if(result!=55) throw Error("Calculation failed");
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>Even though this example is trivial, it is easy to see how the first case, using <strong class="source-inline">expect()</strong>, results in a better developer experience, as it is succinct, elegant, and easy to read.</p> 
			<p class="callout-heading">Vitest is still running!</p> 
			<p class="callout">Perhaps you have noticed that running <strong class="source-inline">npm run test</strong>  does not end the execution of the script once the tests have  terminated. Just like with a developer server, Vitest keeps waiting for  changes to occur to the source code or test files and automatically  reruns all the tests for you. If you want to run the tests only once,  use <strong class="source-inline">npm run test:once</strong> or <strong class="source-inline">vitest –-run</strong> to flag Vitest to run the tests only once and then exit.</p> 
			<h2>Special assertion case – fail on purpose</h2> 
			<p>All the previous assertions thus far  have been made using the “positive” approach that a function will  return what is expected. Using the “negative” approach in testing is to  make sure that a function will fail when it is supposed to. For example,  the Fibonacci series is not defined for negative numbers, so any  calculation should not return a value but should throw an error. In  these cases, we need to wrap the execution of the function in another  function, thus encapsulating it to test the assertion against a thrown  error. This would be the equivalent of using a <strong class="source-inline">try..catch</strong> block in plain JavaScript to avoid terminating the execution of the script when an error occurs. For example, executing <strong class="source-inline">Fibonacci(-5)</strong> should throw an error, so we will write our test case as this:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="source-code"> 
test("Out of range, must fail and throw an error", ()=&gt;{ 
&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">expect(()=&gt;</strong>Fibonacci(-5)<strong class="bold">).toThrow()</strong> 
})
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>The preceding assertion will work as expected, without interrupting the testing process.</p> 
			<h2>Special assertion case – asynchronous code</h2> 
			<p>Another special case to keep in mind  is asynchronous code, such as network calls, promises, and so on. In  this case, the solution is to use <strong class="source-inline">async..await</strong>, not on the function but on <strong class="source-inline">expect</strong>. For example, to test the <strong class="source-inline">FibonacciPromise()</strong> asynchronous function, we would write a test like this:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="source-code"> 
test("Resolve promise", <strong class="bold">async </strong>()=&gt;{ 
<strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;await </strong>expect(FibonacciPromise(10))<strong class="bold">.resolves</strong>.toBe(55) 
})
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>Notice how we are applying the <strong class="source-inline">async</strong> syntax to the entire test function, and <strong class="source-inline">await</strong> to the <strong class="source-inline">expect()</strong> function. We also need to use the <strong class="source-inline">.resolves</strong> assertion to indicate the successful resolution for the value to validate. If we needed to test a <strong class="source-inline">Promise</strong> rejection, we would use <strong class="source-inline">.rejects</strong> instead of <strong class="source-inline">.resolves</strong>.</p> 
			<p>With this, we have covered the majority of tools and test  approaches to get us started in unit-testing our plain JavaScript  functions. However, all these tests are executed using <strong class="bold">Node.js</strong> (the server version of JavaScript), not on the browser where our Vue components will be executed. In Node.js, there is no <strong class="bold">DOM</strong> or <strong class="bold">Windows</strong> object, so we don’t have any HTML... so how do we test our <strong class="bold">Single File Components</strong>? </p> 
			<p>The answer is to provide Vitest with a simulated DOM where we can  mount our components and run tests as if it were a browser window. Here  is where the Vue Test Utils tools come into play.</p> 
			<h1>Installation of Vue Test Utils</h1> 
			<p>As of now, Vitest provides us, out of the box, with tools to test  plain JavaScript functions, classes, events, and so on. To test our  Single File Components, we need additional resources, and these are  provided to us again by the official Vue team in the form of <strong class="bold">Vue Test Utils</strong> (<a href="https://test-utils.vuejs.org/">https://test-utils.vuejs.org/</a>). To install them, run the following command:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ npm install -D @vue/test-utils
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>Once the installation has completed, we need to update our <strong class="source-inline">vite.config.js</strong>  file to include the environment where the components will be tested,  meaning a browser context. Modify the configuration file so it looks like this:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="source-code"> 
export default defineConfig({ 
&nbsp;&nbsp;&nbsp;&nbsp;plugins: [vue()], 
&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">test:{environment:"jsdom"}</strong> 
})
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>Vitest and Vue Test Utils both integrate seamlessly with Vite, to  the point that they share the same configuration file. You can now run  the test suite, and Vitest will attempt to download and install any  missing dependencies on the first run after these modifications. If for  some reason the installation of <strong class="source-inline">jsdom</strong> does not happen automatically, you can install it manually with this command:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ npm install –D jsdom
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>Now, with these changes, we are ready to start our first component tests. Let’s start creating a file to test our <strong class="source-inline">FibonacciOutput.vue</strong> component, as it is the simplest, we have in our application. Create the following file in the test directory with this code:</p> 
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/tests/FibonacciOutput.test.js</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="source-code"> 
import { describe, expect, test } from "vitest" 
<strong class="bold">import { mount } from "@vue/test-utils"</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">#1</strong> 
import <strong class="bold">FibonacciOutput </strong>from "../components/FibonacciOutput.vue"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">#2</strong> 
describe("Check Component props and HTML", () =&gt; { 
&nbsp;&nbsp;&nbsp;&nbsp;test("Props input and HTML output", () =&gt; { 
<strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const wrapper = mount(FibonacciOutput,</strong> 
<strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ props: { number: 10 } })</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">#3</strong> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expect(<strong class="bold">wrapper.text()</strong>).toContain(55)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">#4</strong> 
&nbsp;&nbsp;&nbsp;&nbsp;}) 
})
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>The preceding code is not that different from a basic unit test as  we have done before, but it does some things a bit differently. In line  <strong class="source-inline">#1</strong>, we import a function from  the Vue Test Utils library that allows us to “mount” our component in a  test environment simulating a browser window with Vue 3. In line <strong class="source-inline">#2</strong>, we import our component in the usual way, and then proceed to write our test group as before. The difference here is in line <strong class="source-inline">#3</strong>. We use the <strong class="source-inline">mount</strong>  function to create our live component by passing it as the first  argument and, as the second, we pass an object with properties that will  be applied to the component. In this case, we are passing the <strong class="source-inline">number</strong> prop with a value of <strong class="source-inline">10</strong>. The <strong class="source-inline">mount</strong>  function will return a wrapper object representing our component,  exposing an API that we access to perform our assertions. In this case,  in line <strong class="source-inline">#4</strong>, we are checking that  the plain text rendered by the component contains the value 55, which we  will find to be true when the test is run. It is by using this wrapper  object that we can access the component properties,  events, slots, and rendered HTML by accessing the proper methods. We  will only discuss a few in this chapter, but a full list is available in  the official documentation at <a href="https://test-utils.vuejs.org/api/#wrapper-methods">https://test-utils.vuejs.org/api/#wrapper-methods</a>.</p> 
			<p>This short example gives us a template to write our tests, but now we move to a more complex example to test our <strong class="source-inline">input</strong> component. In the test directory, create the following file:</p> 
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/tests/FibonacciInput.test.js</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="source-code"> 
import { describe, expect, test } from "vitest" 
import { mount } from "@vue/test-utils" 
import FibonacciInput from "../components/FibonacciInput.vue" 
describe("Check Component action and event", ()=&gt;{ 
&nbsp;&nbsp;&nbsp;&nbsp;test("Enter value and emit event on button click",()=&gt;{ 
<strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let wrapper=mount(FibonacciInput)</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">#1</strong> 
<strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wrapper.find("input").setValue(10)</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">#2</strong> 
<strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wrapper.find("button").trigger("click")</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">#3</strong> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Capture the event parameters 
<strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let inputEvents=wrapper.emitted("input")</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">#4</strong> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Assert the event was emitted, and with the correct value 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Each event provides an array with the arguments passed 
<strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expect(inputEvents[0]).toEqual([10])</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">#5</strong> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// or 
<strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expect(inputEvents[0][0]).toBe(10)</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">#6</strong> 
&nbsp;&nbsp;&nbsp;&nbsp;}) 
})
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>This final example starts in the  same way as before, by importing the functions that we will use to  describe the tests, mount our component, and the component itself. Our  purpose here is to simulate to a certain degree the user interaction  with the component by entering a value in the <strong class="source-inline">input</strong>  field, clicking the button, and then capturing the event and the value  passed programmatically. We will rely on the methods just like before.  We start in line <strong class="source-inline">#1</strong> by mounting  our component and creating the wrapper. Notice that, this time, we are  not passing any options, as we don’t need them. In line <strong class="source-inline">#2</strong>, we use the wrapper’s <strong class="source-inline">find()</strong> method to locate an <strong class="source-inline">input</strong> element and set a value of <strong class="source-inline">10</strong>. The <strong class="source-inline">find()</strong> method retrieves elements using a string with the same syntax as <strong class="source-inline">querySelector</strong>  in a browser window. The returned object is a wrapper around the  element, which again exposes methods for users to interact with it – in  this case, <strong class="source-inline">.setValue()</strong>. Using a similar logic, in line <strong class="source-inline">#3</strong>, we also locate the button and trigger the <strong class="source-inline">click</strong> event, which will emit the <strong class="source-inline">input</strong> event in our component. Notice how easy it is in lines <strong class="source-inline">#2</strong> and <strong class="source-inline">#3</strong>  to manipulate our component. In this way, we can access and interact  programmatically with it, much like it could happen in an end-to-end  test. We could, in theory, create our end-to-end tests using this tool,  but there are better options, such as <strong class="bold">Cypress</strong> (<a href="https://www.cypress.io/">https://www.cypress.io/</a>), which work excellently with Vitest, giving us a great DX.</p> 
			<p>In line <strong class="source-inline">#3</strong>, we have clicked a button, which we know should emit an event. In line <strong class="source-inline">#4</strong>, we capture all the emitted events with the name <strong class="source-inline">input</strong>.  The result is an array of wrapped events that we can use in our  assertions, by referencing each event by its ordinal index. In this  case, we only triggered one event, so in line <strong class="source-inline">#5</strong>, we pass that to our expected function as <strong class="source-inline">inputEvents[0]</strong>. However, notice that the assertion matches the output to an array, <strong class="source-inline">[10]</strong>, instead of the value we entered in line <strong class="source-inline">#2</strong>. Why is that? The answer is that each<em class="italic"> event</em>  has an undetermined number of arguments it could pass, so these are  captured in an array. An equivalent notation is shown here in line <strong class="source-inline">#6</strong>, where we pass to <strong class="source-inline">expect()</strong> directly the value of the first element in the array of arguments, from the first event captured: <strong class="source-inline">inputEvents[0][0]</strong>. Then, we can directly validate the result to a value with <strong class="source-inline">.toBe(10)</strong>.  Now, this approach may seem a bit convoluted and clumsy, having to  refer to events and their values in such a way, but it is very powerful.  Consider that we can, in one single line, assert a full array with a  set of related values!</p> 
			<p>In these two files, we have now tested the input and output of our  components and even validated the interactivity as expected. We have  also learned how to retrieve elements rendered and access their  properties. Any error thrown in these functions will invalidate the test  and point us in the right direction, line, and comment on where to fix  it. Placing tests in individual files is a very convenient alternative.  However, Vitest also accepts in-source testing, which we will see next.</p> 
			<h1>In-source testing</h1> 
			<p>With in-source testing, we can  indicate to Vitest to look into our JavaScript and Single Component  Files for the tests to run, as opposed to specific files. These  alternatives are not exclusive to each other, so we could have both  active at the same time. The reason behind this is that, in some cases, a  test case would benefit to be “close” to the original code that it is  trying to assert. Such code must be placed at the end of our file  following this format:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="source-code"> 
if (<strong class="bold">import.meta.vitest</strong>) { 
&nbsp;&nbsp;&nbsp;&nbsp;const { describe, test, expect } = <strong class="bold">import.meta.vitest</strong> 
&nbsp;&nbsp;&nbsp;//... Test functions here 
}
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>Then, for Vitest to find this code in our files, we also need to modify the <strong class="source-inline">vite.config.js</strong> file to include the following:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="source-code"> 
export default defineConfig({ 
&nbsp;&nbsp;&nbsp;&nbsp;test: { 
<strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;includeSource: ['src/**/*.{js,ts}']</strong>, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// other configurations here... 
&nbsp;&nbsp;&nbsp;&nbsp;}, 
})
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>And finally, to eliminate the test code from the production build, we need to add the following before the bundling:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="source-code"> 
export default defineConfig({ 
&nbsp;&nbsp;&nbsp;&nbsp;define: { <strong class="bold">'import.meta.vitest': 'undefined'</strong> }, 
&nbsp;&nbsp;&nbsp;&nbsp;// Other configurations... 
})
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>With these changes, we can then  include the tests at the end of our JavaScript files, with the benefits  and trade-offs that this brings. For example, if there is an in-house  service that is shared or used among projects, it could be a good idea  to place the tests in the same file as opposed to duplicating them for each project.</p> 
			<p>Now that we have our tests in place, let’s see two more benefits that we get from using Vitest:<em class="italic"> coverage</em> and a live<em class="italic"> </em><em class="italic">web UI.</em></p> 
			<h1>Coverage</h1> 
			<p>The concept of coverage is very  simple, and it answers the question of how much of our code is covered  by automated tests. We know that 100% coverage is only possible for  small applications, as the same effort for large projects falls fast  into the law of diminishing returns Vitest offers us a simple way to  answer this question by running the <strong class="source-inline">vitest –coverage</strong> command. In our case, we have already set this option in our <strong class="source-inline">package.json</strong> scripts section, so we can run the following command:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ npm run test:coverage
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>When the preceding command is run, if any dependency is missing, it will prompt us on whether we want to try to download and install it:</p> 
			<div> 
				<div class="IMG---Figure"> 
					<img src="Chapter%2099%20Testing%20and%20Source%20Control%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_9.03_B18602.jpg" alt="Figure 9.3 – Vitest prompts us to install missing dependencies for coverage" width="740" height="109"> 
				</div> 
			</div> 
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Vitest prompts us to install missing dependencies for coverage</p> 
			<p>For our chapter code example, the coverage report should look something like this:</p> 
			<div> 
				<div class="IMG---Figure"> 
					<img src="Chapter%2099%20Testing%20and%20Source%20Control%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_9.04_B18602.jpg" alt="Figure 9.4 – Vitest coverage report example" width="608" height="308"> 
				</div> 
			</div> 
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Vitest coverage report example</p> 
			<p>It is possible to retrieve this information on a file (as <strong class="source-inline">json</strong>, <strong class="source-inline">text</strong>, or <strong class="source-inline">html</strong>) if we need to. For that, we just need to include a new line in our <strong class="source-inline">vite.config.js</strong> file:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="source-code"> 
test:{ 
&nbsp;&nbsp;&nbsp;&nbsp;coverage: {reporter: ['text', 'json', 'html']}, 
&nbsp;&nbsp;&nbsp;&nbsp;//... 
}
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>The result of running the command again will be a website placed in a new directory called <strong class="source-inline">coverage</strong> at the root of our project. This static website provides for navigation and drills down in the report. 
In our example, it looks like this:</p> 
			<div> 
				<div class="IMG---Figure"> 
					<img src="Chapter%2099%20Testing%20and%20Source%20Control%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_9.05_B18602.jpg" alt="Figure 9.5 – Coverage HTML report" width="1029" height="294"> 
				</div> 
			</div> 
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Coverage HTML report</p> 
			<p>Depending on our needs, this simple tool may provide us with  insight into our project that would be hard to find otherwise. The  export to JSON file comes also very handy if we need to integrate our  project with other reporting software or format. There is yet another  alternative that may come in handy: Vitest also provides a web UI to  view and interact with the tests in the form of a dashboard. We will see  this next.</p> 
			<h1>The Vitest UI</h1> 
			<p>Since Vitest is based on Vite, it does make  good use of some of its features, not only for live testing but also to  provide a live development server displaying the tests in real time. To  make use of this option, we only need to install the appropriate  dependency as follows:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ npm install –D @vitests/ui
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>Then, for convenience, we should add the following line in our <strong class="source-inline">package.json</strong> file so we can run the application using <strong class="source-inline">npm</strong>:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="source-code"> 
scripts:{ 
&nbsp;&nbsp;&nbsp;&nbsp;"<strong class="bold">test:ui</strong>": "<strong class="bold">vitest –-ui</strong>" 
&nbsp;&nbsp;&nbsp;&nbsp;// Other settings... 
}
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>We can then run the server with this command line:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ npm run test:ui
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>The development test server will start and provide us with an address to open in the browser. For our application, this looks like this:</p> 
			<div> 
				<div class="IMG---Figure"> 
					<img src="Chapter%2099%20Testing%20and%20Source%20Control%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_9.06_B18602.jpg" alt="Figure 9.6 – Vitest UI dashboard" width="981" height="373"> 
				</div> 
			</div> 
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Vitest UI dashboard</p> 
			<p>The web UI has also new  possibilities to interact with the test cases, and even see the  relationships between components and services in a graphical manner, all  the way down to the test code.</p> 
			<p>Now that we have cleaned up our code and run tests, it is time to  look into another tool to keep track of changes, a fundamental concept  for today: source control with Git.</p> 
			<h1>What is source control... and why?</h1> 
			<p>Software development is a “human-intensive” discipline, meaning  that it depends heavily on the creativity and involvement of the  developer and their know-how. It is common to try different approaches  to the same situation and write and rewrite code. Even the process of  refactoring after testing implies making changes in the code. It is not  an anomaly that during this process, we need to “go back” to a previous  code when a change or approach didn’t meet expectations. If we are  constantly overwriting the same files... how do we keep track of what  changed where? And by whom? Our own memory is not enough when time and  complexity grow. Save files with different names? That would become  impractical very soon. And what about combining source code from  multiple developers? We can quickly see that managing the source code  for non-trivial projects is a very important task in itself.</p> 
			<p>The historical solution to this early problem in computer science  has been the creation of additional software in charge of keeping track  of changes in the code, allowing a developer to go back on their tracks,  and facilitating the chore of merging code from multiple developers to  make a cohesive source code. The emerging discipline for this task is  called <strong class="bold">Source Control</strong> (<strong class="bold">SC</strong>), and the software to implement it is called a <strong class="bold">Source Control System</strong> (<strong class="bold">SCS</strong>) or <strong class="bold">Source Control Management System</strong> (<strong class="bold">SCMS</strong>). There have been many, and still are many, different systems in use today, such as <strong class="bold">Mercurial</strong>, <strong class="bold">Subversion</strong>, <strong class="bold">ClearCase</strong>, <strong class="bold">Git</strong>, and <strong class="bold">BitKeeper</strong>. Each one has its trade-offs. In particular, Git is used today by most projects and developers  around the globe. Statistics on the internet show different percentages  for the most popular ones, but each one shows this trend. Because of  this, it is important that we learn how to use Git, which is our next topic.</p> 
			<h1>Source control with Git</h1> 
			<p>Currently, the most popular SCS is Git, which was created by <strong class="bold">Linus Torvalds</strong>, who is also the creator of the Linux kernel. The story goes that the Linux kernel project used <em class="italic">BitKeeper </em>for  source control, but the team hit many issues with the growing  complexity and distributed nature of the development. Frustrated, Linus  Torvalds decided to make his own SCS to solve the real-life problems  they had... and it took him one weekend! (See <a href="https://www.linux.com/news/10-years-git-interview-git-creator-linus-torvalds/">https://www.linux.com/news/10-years-git-interview-git-creator-linus-torvalds/</a>.) That was the humble beginning of Git, and from there, it became popular in the open source community as well as in the enterprise world.</p> 
			<p>Git is a distributed SCMS, simple and effective to use from the command line. It offers the following features:</p> 
			<ul> 
				<li>Creates and manages a <strong class="bold">repository</strong>, where it collects the source files and the history of changes for each one.</li> 
				<li>Allows sharing projects by cloning <strong class="bold">remote repositories</strong> into local projects.</li> 
				<li>Allows the project to be branched and merged. This means that  you can have different copies of the same project with different code (a  <strong class="bold">branch</strong>), switch between them, join them, and unify them by request (a <strong class="bold">merge</strong>).</li> 
				<li>Synchronizes changes from a remote repository into a local copy (called a <strong class="bold">pull</strong>).</li> 
				<li>Sends local changes to a remote repository (called a <strong class="bold">push</strong>).</li> 
			</ul> 
			<p>Let’s learn how to use Git by applying it to our current project  for this chapter. Let’s start by installing it in our system, so it’s  available for all our projects.</p> 
			<h2>Installation on Windows systems</h2> 
			<p>The easiest and recommended way to install Git on Windows systems is to download the installers from the official Git website at <a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a>.  Click on the version you want to use, according to your operating  system (32- or 64-bit), and then run the installer following the directions.</p> 
			<div> 
				<div class="IMG---Figure"> 
					<img src="Chapter%2099%20Testing%20and%20Source%20Control%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_9.07_B18602.jpg" alt="Figure 9.7 – Official Git installers for Windows" width="832" height="311"> 
				</div> 
			</div> 
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Official Git installers for Windows</p> 
			<p>Once the installation is done, the command-line tools will be  installed on your system so we can run them through a terminal. Also, if  you are using a code editor such as Visual Studio Code, it will  integrate the tools and provide you with a GUI to handle basic operations.</p> 
			<h2>Installation on Linux systems</h2> 
			<p>In Linux systems, the installation is done through the command line, using the distribution’s package manager. The package name in (almost) all distributions is simply <strong class="source-inline">git</strong>. In Debian and Ubuntu systems, the installation can be run with the following:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ sudo apt install git
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>However, in these distributions, there may not be the latest  version, so if you need the latest stable release, you need to add the  official PPA repository. In this case, run the following commands in order:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ sudo add-apt-repository ppa:git-core/ppa 
$ sudo apt update 
$ sudo apt install git
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>The preceding commands will update your system dependencies and  install (or upgrade) Git on your system. For a complete list of  distributions and commands to install Git, please refer to the official  documentation at <a href="https://git-scm.com/download/linux">https://git-scm.com/download/linux</a>.</p> 
			<h2>Installation on macOS systems</h2> 
			<p>In macOS systems, there are different ways to install Git:</p> 
			<ul> 
				<li>If you have Homebrew installed, run <strong class="source-inline">$ brew install git</strong> in a Terminal</li> 
				<li>If instead, you have MacPorts, run <strong class="source-inline">$ sudo port install git</strong> in a Terminal</li> 
				<li>If you have installed Xcode, Git is included</li> 
			</ul> 
			<p>For other alternatives, please check the official documentation at https://git-scm.com/download/mac.</p> 
			<h2>Using Git</h2> 
			<p>Regardless of which system you are  working on, or the installation type you made, Git will be installed in  your local path, so it can be executed from any terminal window. To  verify the installation and version, run this command (does not require admin privileges):</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ git –-version
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>At the time of writing, the current stable version is <em class="italic">2.39.2</em>.  With this done, open a terminal window in the root folder of our  project. To start using Git, we need to create a local repository with this command:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ git init
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>After the execution is done, a new hidden directory will be  created in the folder. You don’t have to worry about it, as it will be  managed by Git. If your File Explorer has deactivated the option to see  hidden files, then you may not notice the creation. It is recommended  that you have <strong class="bold">Show/view hidden files</strong> in your system activated.</p> 
			<p>Once we have created the repository, we can start using it. The steps to work with files usually includes the following stages:</p> 
			<div> 
				<div class="IMG---Figure"> 
					<img src="Chapter%2099%20Testing%20and%20Source%20Control%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_9.08_B18602.jpg" alt="Figure 9.8 – Working stages of Git" width="831" height="105"> 
				</div> 
			</div> 
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Working stages of Git</p> 
			<p>Once we have files created or edited, the next step is to “stage”  the files. This indicates to Git that it needs to keep track of changes  and include the file in the next commit event. <strong class="bold">Committing</strong> is the act  of moving those files/changes into the repository. If a file is not  staged, it will not be included in the commit. To add a file, run the following command:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ git add [filename1] [filename2]..
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>This will add the files, but it is quite verbose. Instead, if you want to add all changes in all files, run this instead:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ git add .
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>This will come in handy in the first commit when the repository is  initialized. After running this command, all the files will start to be  tracked. However, we do not want to track everything in our root  folder, so to exclude files or directories, we can use a special file  named <strong class="source-inline">.gitignore</strong>. If you open this file in the example directory, you will find something like this:</p> 
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/chapter 10/.gitignore</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="source-code"> 
logs 
*.log 
npm-debug.log* 
yarn-debug.log* 
yarn-error.log* 
pnpm-debug.log* 
lerna-debug.log* 
node_modules 
dist 
dist-ssr 
*.local 
.vscode/* 
!.vscode/extensions.json 
.idea 
.DS_Store 
*.suo 
*.ntvs* 
*.njsproj 
*.sln 
*.sw?
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>This is a plain text file that indicates to Git not to track the  files and directories indicated in each line. You can also use wildcards  such as an asterisk (<strong class="source-inline">*</strong>) and question mark (<strong class="source-inline">?</strong>)  to include a match pattern. This is very useful, as there are parts of  your code base that you don’t need to track, such as the node  dependencies and binary files (images and the like). Make sure to have  this file in your directory before making a massive staging.</p> 
			<p>Once you have staged files, you can check them with this command:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ git status
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>In the case of our example project, it will show something like this:</p> 
			<div> 
				<div class="IMG---Figure"> 
					<img src="Chapter%2099%20Testing%20and%20Source%20Control%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_9.09_B18602.jpg" alt="Figure 9.9 – First staging in Git" width="764" height="403"> 
				</div> 
			</div> 
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – First staging in Git</p> 
			<p>Notice how Git informs us also that we are in the <strong class="source-inline">master</strong> branch, and that there have not been any commits yet. The <strong class="source-inline">master</strong>  branch is the main branch for our code and is created by default. This  is a special branch that is used to keep the stable code of our  applications. In tools such as GitLab and GitHub (we will talk about  them later), these branches also trigger certain events once committed.  For now, let’s move forward and create our first commit with this command:</p> 
			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ git commit –m "First commit"
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
			<p>We will see results like this:</p> 
			<div> 
				<div class="IMG---Figure"> 
					<img src="Chapter%2099%20Testing%20and%20Source%20Control%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_9.10_B18602.jpg" alt="Figure 9.10 – Results from the first commit" width="647" height="328"> 
				</div> 
			</div> 
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Results from the first commit</p> 
			<p>With these simple lines, we have started to keep track of our  source code. Now, as mentioned before, we have committed our initial  code to the <strong class="source-inline">master</strong> branch. Git  allows us to make an instant copy of the state of our code, much like a  screenshot, and continue working from there without affecting the  original. This is called <strong class="bold">branching</strong> and is an important part of using Git.</p> 
			<h2>Managing branches and merges</h2> 
			<p>Using branches to control our development is a very good way to move forward on a certain footing. Here are the most common commands to manage branches:</p> 
			<table id="table001-5" class="No-Table-Style"><colgroup><col><col></colgroup><tbody><tr class="No-Table-Style"><td class="No-Table-Style"> 
							<p>Action</p> 
						</td><td class="No-Table-Style"> 
							<p>Command example</p> 
						</td></tr><tr class="No-Table-Style"><td class="No-Table-Style"> 
							<p>Create a branch and switch to it</p> 
						</td><td class="No-Table-Style"> 
							<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ git checkout –b [branch_name]
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
						</td></tr><tr class="No-Table-Style"><td class="No-Table-Style"> 
							<p>Create a branch but stay in current</p> 
						</td><td class="No-Table-Style"> 
							<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ git branch [branch_name]
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
						</td></tr><tr class="No-Table-Style"><td class="No-Table-Style"> 
							<p>Delete branch</p> 
						</td><td class="No-Table-Style"> 
							<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ git branch –d [branch_name]
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
						</td></tr><tr class="No-Table-Style"><td class="No-Table-Style"> 
							<p>Switch to a branch</p> 
						</td><td class="No-Table-Style"> 
							<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ git checkout [branch_name]
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
						</td></tr><tr class="No-Table-Style"><td class="No-Table-Style"> 
							<p>Merge a branch with current</p> 
						</td><td class="No-Table-Style"> 
							<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ git merge [branch_name]
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
						</td></tr><tr class="No-Table-Style"><td class="No-Table-Style"> 
							<p>Check current branch</p> 
						</td><td class="No-Table-Style"> 
							<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
$ git branch
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div> 
						</td></tr></tbody></table> 
			<p>Once you have moved to another branch, you can perform all the  regular Git operations (edit and delete files, etc.) without affecting  the other ones.</p> 
			<h2>Merging conflicts</h2> 
			<p>When merging multiple branches together or with <strong class="source-inline">master</strong>, it is possible and more than likely that some files will have a discrepancy with the current branch. In this case, the <em class="italic">merge </em>will  fail, and the user will be prompted to solve the differences. What Git  does is mark the target file (the file in the current branch) with  markers in the text for the user to edit. Once these have been edited,  the file can be staged and committed, thus ending the <em class="italic">merge</em>. Let’s try that without code, by purposely creating a discrepancy to fix. Follow these steps:</p> 
			<ol> 
				<li>Create a new branch, <strong class="source-inline">dev</strong>, with this command: <strong class="source-inline">$ git checkout –</strong><strong class="source-inline">b dev</strong>.</li> 
				<li>Edit <strong class="source-inline">index.html</strong>, adding in line 11 (before the script tag) the following: <strong class="source-inline">&lt;div&gt;A div created in </strong><strong class="source-inline">branch dev&lt;/div&gt;</strong>.</li> 
				<li>Save the file, stage it, and commit the change with <strong class="source-inline">$ git add index.html</strong> and then <strong class="source-inline">$ git commit –m "added div </strong><strong class="source-inline">in dev"</strong>.</li> 
				<li>Now, we will move to the <strong class="source-inline">master</strong> branch with <strong class="source-inline">$ git </strong><strong class="source-inline">checkout master</strong>.</li> 
				<li>Notice how line 11 with the div has disappeared from <strong class="source-inline">index.html</strong>. This is because that edition was never made on this file. Now, add in that line the following: <strong class="source-inline">&lt;p&gt;This change was made </strong><strong class="source-inline">in master&lt;/p&gt;</strong>.</li> 
				<li>Save the file, stage it, and commit it with a different message (look at <em class="italic">step 3</em>).</li> 
			</ol> 
			<p>Now, we will try to merge both branches and, as <strong class="source-inline">index.html</strong> has been committed to both with a different code, it will fail! To start the <em class="italic">merge</em>, run <strong class="source-inline">$ git merge dev</strong>.</p> 
			<p>You should see an error on the terminal, and new lines added to <strong class="source-inline">index.html</strong> indicating the discrepancies. In our code example, it looks like this:</p> 
			<div> 
				<div class="IMG---Figure"> 
					<img src="Chapter%2099%20Testing%20and%20Source%20Control%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_9.11_B18602.jpg" alt="Figure 9.11 – Merge conflict" width="699" height="171"> 
				</div> 
			</div> 
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Merge conflict</p> 
			<ol> 
				<li value="7">To resolve the conflict, just edit the source code to  your best judgment (also delete the extra labels added by Git), then  save the file, stage it, and finally make a commit. You will receive a message indicating that the <em class="italic">merge </em>has been resolved.</li> 
			</ol> 
			<p>Working with branches and resolving mergers when they appear is a  common practice and quite useful, but we are still not using the full  potential of Git. As you remember, Git is a distributed SCMS, and this  relies on its great potential. Enter the remote repository...</p> 
			<h2>Working with remote repositories</h2> 
			<p>In the same way that we work with a  local repository, Git can also synchronize code with a remote  repository. This enables team members from anywhere in the world to  collaborate together in the same code base, resolve conflicts, and also  synchronize their own code with others’ contributions. Working with a  remote repository involves the following steps to set up:</p> 
			<ol> 
				<li>The remote repository must be created, and a URL provided to connect to it.</li> 
				<li>We add the remote repository as a new origin to our local repository with the following command:<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
<strong class="bold">$ git remote add origin URL</strong>
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div></li> 
				<li>We set our <strong class="source-inline">master</strong> branch to synchronize with the remote repository:<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
<strong class="bold">$ git push –set-upstream origin master</strong>
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div></li> 
				<li>We retrieve changes from the remote repository:<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
<strong class="bold">$ git pull origin master</strong>
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div></li> 
				<li>We submit our changes to the remote repository:<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer">
<pre class="console"> 
<strong class="bold">$ git push origin master</strong>
</pre>
<div class="orm-ChapterReader-snippetButtonContainer"></div></div></li> 
			</ol> 
			<p>Once you have done <em class="italic">steps 1</em> to <em class="italic">3</em>, the regular activity will involve <em class="italic">steps 4</em> and <em class="italic">5</em>.  These activities will keep your local repository synchronized with your  remote repository. In practice, modern IDEs such as Visual Studio Code  will already provide you with graphical tools to make these operations,  and this results in more convenience when you are working on a project.  They also include visual tools to resolve conflicts during <em class="italic">merges</em>.</p> 
			<p>Setting up a Git server for your local network is outside the  scope of this book, but this introduction would not be complete without a  word about <strong class="bold">GitHub </strong>and <strong class="bold">GitLab</strong>. It is common that when people first hear about Git, they associate it with GitHub, which is understandable, as the latter has a much more popular media presence. GitHub is not Git. It is a web platform that provides  tools built on top of Git, to host online projects hosting remote  repositories. Thus, you can perfectly work with Git locally, and  synchronize with a GitHub or GitLab remote repository. This is the most common case.</p> 
			<p>GitHub provides messaging and documentation tools, and much more –  even additional services that allow detecting events in our repository  to trigger certain actions and services, some provided locally (at a  cost), others remotely (for example, webhooks). For example, it is  possible for you to commit locally, push the changes to the <strong class="source-inline">master</strong> branch on GitHub, and  have a whole set of routines started, from compilation to website  presentation. Again, managing all these options is outside our current  scope in this chapter, but the important thing to remember is that all  of this is based and built upon Git, so if you understand <em class="italic">how </em>it the works and <em class="italic">what </em>it  does, you have a solid foundation to move ahead with other tools and  services. There is one more concept that has become familiar with this  topic, Continuous Integration and Delivery, which we will see next.</p> 
			<h1>Continuous Integration and Delivery</h1> 
			<p><strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>) is a  practice enabled by the technologies we have seen thus far, where  developers commit their changes to a central (remote) repository as  frequently as possible. The central repository detects the incoming  changes and triggers automated tests against the code. Then, it  compiles/builds the final product. This is done continuously, as opposed  to the practice of merging and compiling on a given date before launch.</p> 
			<p><strong class="bold">Continuous Delivery</strong> (<strong class="bold">CD</strong>) builds on  top of CI, by also deploying the released product to its final  location. You can configure this process to create preliminary versions  of software or web applications, (for example, betas, nightly builds,  etc.), and program a release date for the end location and delivery to  the customers (sometimes, this last part may involve a process of its  own and is called <strong class="bold">Continuous Deployment</strong>). Both services mentioned before (GitHub and GitLab) offer these types of services.</p> 
			<p>By using these concepts, it is possible to set up a whole  automated workflow from your desktop to the web, where a simple Git  commit and a push to the server would trigger your application to be  tested and published in its destination online. The way to implement  this workflow is particular to the tool used to implement CI and CD.</p> 
			<h1>Summary</h1> 
			<p>In this chapter, we have covered very important concepts regarding  the care and quality of our code. We have learned how to install  official tools to perform automated tests in our code and components, as  well as how to keep track of changes and management in the source code.  While the examples and information provided here are introductory, they  are detailed enough to implement them in your own projects and keep  your learning skills growing. The concepts of CI and CD, as well as  services provided by online repositories, also give you a solid  foundation to learn to use them, as they all are based on the  functionality provided by Git. All these tools have professional value  for a developer and are required in the industry today.</p> 
			<h1>Review questions</h1> 
			<ul> 
				<li>Why is automated testing important? Does it eliminate the need to perform manual testing?</li> 
				<li>What is necessary to test our Single File Components in Vue?</li> 
				<li>What is source control, and why is it necessary?</li> 
				<li>What is Git, and how is it different from GitHub/GitLab?</li> 
				<li>When you modify a file in a branch, does that modify it in all other branches? Why does or doesn’t this happen?</li> 
				<li>Are the commands to control Git the same across all platforms?</li> 
				<li>What do CI and CD stand for, and what is the value they add to a workflow?</li> 
			</ul>