			<h1>Тестирование и контроль исходных текстов</h1>
			<p>Успех нашего приложения зависит от многих факторов, помимо качества организации кода или паттернов. Более того, сама природа программного обеспечения подразумевает, что во время и после разработки будут происходить изменения, меняться требования, область применения и т.д. С каждой разработанной функцией в программное обеспечение вносится элемент сложности, создающий взаимосвязи и зависимости. Новые включения могут нарушить эти связи и внести разрывные изменения, привести к ошибкам или даже полностью вывести систему из строя. Решением этой проблемы является отслеживание изменений кода и проведение тестов приложения для выявления проблем и максимального обеспечения соответствия системы желаемым атрибутам ПО и удовлетворения требований.</p> <p> В этой главе мы рассмотрим, как можно более точно определить, что происходит в системе.
			<p>В этой главе мы рассмотрим следующее:</p>
			<ul>
				<li>Различные подходы к тестированию и концепция <b>тестовой</b><b> разработки (TDD)</b></li>.
				<li>Установка тестового пакета (Vitest) и инструментов тестирования (Vue Test Utils) для нашего проекта</li>.
				<li>Создание и запуск тестов на существующем проекте для синхронного и асинхронного кода</li>
				<li>Тестирование наших компонентов с помощью симуляции взаимодействия с пользователем</li> <li>Создание и запуск тестов на существующем проекте для синхронного и асинхронного кода</li> <li>Создание и запуск тестов для синхронного и асинхронного кода.
				<li>Установка и управление нашим исходным кодом с помощью Git и онлайн-репозиториев, таких как GitHub или GitLab</li>.
			</ul>
			<p>Представленные в этой главе концепции являются введением в важные профессиональные навыки разработчика, обеспечивающие создание качественного программного обеспечения. Часто эти задачи остаются в стороне или отходят на второй план. Однако их отсутствие может привести к дорогостоящим ошибкам и длительному переутомлению по мере роста сложности программного обеспечения. Для нетривиальных приложений, в которых задействовано более одного разработчика, в настоящее время
вряд ли можно представить себе проект, в котором не использовались бы некоторые из этих инструментов.</p> <p> В этой главе мы расскажем о том, что в процессе работы над приложениями, не являющимися сложными, в которых задействовано несколько разработчиков.
			<p>В этой главе мы сосредоточимся на <b>блочном тестировании</b> и инструментах, предоставляемых командой Vue для его выполнения.</p>
			<h1>Технические требования</h1>
			<p>Эта глава не имеет дополнительных требований по сравнению с предыдущими реализациями примеров кода. Окончательный исходный код можно найти в официальном репозитории этой книги по адресу <a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter09">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter09</a>.</p>
			<p>Посмотрите следующее видео, чтобы увидеть код в действии: <a href="https://packt.link/UqRIi">https://packt.link/UqRIi</a></p> <p>
			<h1>Что такое тестирование и TDD</h1>
			<p>Тестирование - это процесс проверки того, что программное обеспечение делает то, что должно делать, в соответствии с требованиями проекта. Оно включает в себя ручное или автоматизированное выполнение инструментов для оценки и измерения различных свойств и атрибутов программного обеспечения, выявления ошибок и багов и предоставления обратной связи разработчикам для принятия мер по их устранению. Существует множество различных подходов и типов выполняемых тестов, например, следующие:</p>
			<ul>
				<li><b>Единичное тестирование</b>: при этом соответствующие единицы исходного кода проверяются на соответствие ряду входных и выходных данных. Часто оно автоматизировано.</li>
				<li><b>Интеграционное тестирование</b>: Все компоненты системы проверяются вместе как единое целое, при этом ищутся ошибки и недочеты в интеграции, взаимодействии и т.д. </li> <li><b>Всестороннее тестирование</b>.
				<li><b>Конечное тестирование</b>: предполагает полную проверку приложения, имитирующую его использование в реальных условиях, взаимодействие с базами данных, сетевые сценарии и т.д. Оно может проводиться как с помощью автоматизированных средств, имитирующих взаимодействие с человеком, так и вручную с использованием реальных пользователей.</li>
			</ul>
			<p>Перечисленные виды тестирования - лишь малая часть этой дисциплины, поскольку существуют сотни возможных тестов, которые можно применить к программному обеспечению. В крупных компаниях могут существовать целые группы тестирования, занимающиеся обеспечением качества программного обеспечения. Как правило, чем сложнее программное обеспечение, тем сложнее может быть и тестирование. На практике план тестирования может быть не менее сложным, чем сам план разработки. Как уже говорилось во введении, мы остановимся на официальных инструментах, предоставляемых командой Vue для решения этой задачи.</p> <p>Тестирование - это не просто тестирование, а тестирование, которое может быть выполнено с помощью инструментов.
			<p>Тестирование может проводиться до, во время, после или параллельно с разработкой. <b>TDD</b> - это дисциплина, которая возлагает бремя тестирования как можно раньше в проекте, даже до начала фактического кодирования, с целью соответствия требованиям. Она включает в себя следующие этапы:</p>
			<ol>
				<li>Написание тестового случая, основанного на требованиях и дизайне приложения, с указанием ключевых входов и ожидаемых выходов.</li>
				<li>Запуск теста, который должен завершиться неудачей (поскольку код еще не написан).</li>
				<li>Напишите реальный код для тестирования (функцию, компонент Vue и т.д.).</li>
				<li>Запустите тест на созданном коде. В случае неудачи рефакторингуйте код или дизайн.</li>
				<li>Начните с нового тестового случая для следующего блока.</li>
			</ol>
			<p>Этот процесс повторяется, и ожидается, что он обеспечит разработчикам значительное сокращение "багов" и ошибок и поможет им сосредоточиться на требованиях. Правда, это требует дополнительных усилий на ранних этапах проекта, в отличие от рефакторинга, когда тесты выполняются в конце.</p> <p>TDD получил широкую популярность.
			<p>TDD стал популярным в некоторых командах и с некоторыми фреймворками, и предполагается, что он поможет разработчикам улучшить свой собственный код, поскольку они теперь приобретают "тестирующее" мышление. Однако специальных исследований, подтверждающих это, не проводилось, но практикующие эту дисциплину отмечают, что она улучшила их код и дизайн. В связи с этим, конечно же, возникает вопрос: что нужно тестировать и как можно оптимизировать эту задачу в нашем рабочем процессе? Именно эту тему мы и рассмотрим далее.</p>
			<h1>Что тестировать</h1>
			<p>Одним из ключевых факторов успеха хорошего плана тестирования и его реализации является решение вопроса о том, что тестировать. Невозможно протестировать всю совокупность возможностей или 100% компонентов и взаимодействий в проекте с учетом внутренних и внешних факторов. Даже попытка полностью охватить все возможности будет невероятно дорогой и практически невозможной. Вместо этого необходимо сосредоточиться на реальных возможностях того, что можно протестировать в рамках наших временных и бюджетных ограничений, тщательно отобрав нетривиальные элементы, которые "делают или ломают" наши требования к проекту. Зачастую это нелегкая задача.</p>
			<p>Когда речь идет о Vue-приложениях, нам необходимо сосредоточиться на важнейших сервисах и компонентах, выполняющих ключевые операции. Нам необходимо протестировать следующее:</p>
			<ul>
				<li><b>Сервисы</b>: Самостоятельные функции, как синхронные, так и асинхронные. Функции, которые не возвращают значения, но выполняют логические процедуры, будут служить для другого вида тестирования, чем то, которое мы рассмотрим здесь. Они будут связаны с имитацией сетевых взаимодействий или вызовов баз данных, политик приложения и т.д. Однако принципы их тестирования схожи.</li>
				<li><b>Компоненты</b>: Нам необходимо тестировать входы (реквизиты) и выходы (события и HTML). Компоненты более высокого уровня, объединяющие другие компоненты для выполнения рабочего процесса или бизнес-логики, также могут быть протестированы аналогичным образом (реквизиты, события и HTML-вывод). Однако для них также потребуются другие виды тестирования, например, сквозное тестирование.</li>
			</ul>
			<p>Мы можем написать собственные функции и инструменты для выполнения тестов, но, за исключением некоторых крайних случаев, очевидной рекомендацией является использование стабильных тестовых наборов и инструментов. В нашем случае для Vue существуют официальные ресурсы, предоставляемые той же командой, под названием <b>Vitest</b> и <b>Vue Test Utils</b>. Использование тестового пакета/библиотеки имеет множество преимуществ, схожих с использованием фреймворка или библиотеки при "обычной" разработке приложения. Пожалуй, одно из главных преимуществ связано с <b>DX</b>, или <b>Developer eXperience</b>, поскольку они оптимизируют и облегчают процесс разработки, а в лучшем случае - делают его более легким.  Давайте научимся применять эти инструменты в нашем рабочем процессе на примере приложения, которое мы рассмотрим в следующем разделе.</p> <p>
			<h1>Наш базовый пример приложения</h1>
			<p>Понимать дисциплину тестирования и знакомиться с инструментами лучше всего, применяя их на практике в реальном проекте. В качестве учебного упражнения мы сначала возьмем работающее приложение, основанное на одном из примеров, представленных в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_02.xhtml#_idTextAnchor040"><em class="italic">главе 2</em></a>, <em class="italic">Принципы и паттерны проектирования программного обеспечения</em>. Мы создадим калькулятор <b>Фибоначчи</b> и установим в проект тестовый пакет Vitest и утилиты Vue Testing Utils.  Позже мы объясним, что изменится в этом подходе при применении дисциплины TDD.</p> <p>
			<p>Код этого приложения можно найти в репозитории к этой главе. После загрузки
необходимо выполнить следующую команду для установки зависимостей:</p> <p>
			<div>
<pre class="console">
$ npm install
</pre>
</div>
			<p>Для запуска приложения необходимо выполнить следующие действия:</p>
			<div>
<pre class="console">
$ npm run start
</pre>
</div>
			<p>После того как сервер будет готов, при загрузке сайта в браузере должно появиться приложение следующего вида:</p>
			<div>
				<div>
					<img src="files/Figure_9.01_B18602.jpg" alt="Рисунок 9.1 - Пример приложения с калькулятором Фибоначчи" width="1331" height="231">
				</div>
			</div>
			<p>Рисунок 9.1 - Пример приложения с калькулятором Фибоначчи</p>
			<p>Данное приложение создано с целью изучения основ тестирования функций и компонентов, поэтому оно является очень базовым, но достаточным. Нам представлен один служебный файл (<b class="source-inline">/src/services/Fibonacci.js</b>) и три компонента: <b class="source-inline">App.vue</b>, <b class="source-inline">FibonacciInput.vue</b> и <b class="source-inline">FibonacciOutput.vue</b>.</b>
			<div>
				<div>
					<img src="files/Figure_9.02_B18602.jpg" alt="Рисунок 9.2 - Компоненты и сервис для приложения" width="640" height="206">
				</div>
			</div>
			<p>Рисунок 9.2 - Компоненты и сервис для приложения</p>
			<p>Наш компонент уровня приложения, <b class="source-inline">App.vue</b>, получает от <b class="source-inline">FibonacciInput.vue</b> целое положительное число через событие, которое передает в качестве входного реквизита в <b class="source-inline">FibonacciOutput.vue</b>. Этот компонент использует сервис <b class="source-inline">Fibonacci.js</b> для вычисления соответствующего числа Фибоначчи, входящего в серию, и представления его пользователю. Как бы просто ни звучало это приложение, оно дает нам базовые примеры для создания тестов для наиболее распространенных случаев, что позволит нам взять уверенный старт. Теперь настало время установить наш тестовый пакет.</p>
			<h1>Установка и использование Vitest</h1>
			<p><b>Vitest</b> (<a href="https://vitest.dev/">https://vitest.dev/</a>) - это тестовый пакет, то есть он предоставляет из коробки набор инструментов и фреймворк для выполнения тестов в нашем коде. Разработанный командами Vue и Vite, он легко интегрируется с Vite, даже имеет одну и ту же конфигурацию и уважает организацию друг друга. <em class="italic">Vitest </em> можно выбрать при создании проекта Vue, выбрав соответствующую опцию в мастере создания - эта задача добавит папку <b class="source-inline">/src/__tests__</b>, несколько примеров и несколько дополнительных записей в наш файл <b class="source-inline">package.json</b>. Но вся эта шаблонная информация может несколько сбить с толку, если у нас нет опыта работы в этой области. Вместо этого мы начнем с уже созданного проекта и установим Vitest в качестве зависимости разработки - задача, которая позволит нам понять, как он работает и организован.</p> <p>
			<p>Установите Vitest из командной строки в корневой каталог проекта с помощью следующей команды:</p>
			<div>
<pre class="console">
$ npm install -D vitest
</pre>
</div>
			<p>Менеджер пакетов потратит некоторое время на включение Vitest и всех необходимых зависимостей, но не изменит наш исходный код и организацию.  Для удобства мы будем использовать <b class="source-inline">npm</b> и для запуска наших тестов, поэтому нам нужно открыть наш файл <b class="source-inline">package.json</b> и в секции <b class="source-inline">scripts</b> ввести следующие строки, чтобы секция выглядела следующим образом:</p> <div>
			<div>
<pre class="source-code">
"scripts": {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "start": "vite",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "build": "vite build",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "preview": "vite preview",
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "test": "vitest",</b>.
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "test:once": "vitest run",</b>.
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "test:coverage": "vitest run --coverage"</b>.
}
</pre>
</div>
			<p>На этом этапе мы можем протестировать наш тестовый набор:</p>
			<div>
<pre class="console">
$ npm run test
</pre>
</div>
			<p>После выполнения этой команды вас любезно встретит красное сообщение о том, что тесты не прошли. Идеально. Так и должно быть, ведь у нас еще нет ни одного теста! Итак, давайте их добавим. Начнем с тестирования нашего сервиса <b class="source-inline">Fibonacci.js</b>.</p>
			<p>Vitest позволяет нам писать наши тестовые функции в независимых файлах или in-source, то есть размещать их рядом с JavaScript нашего компонента. В обоих подходах есть свои преимущества и недостатки, но для начала мы разместим наш тестовый код в независимых файлах, по одному для каждого сервиса и компонента. Таким образом, мы разместим эти файлы в собственной директории, которая по условию может быть либо <b class="source-inline">/src/tests</b>, либо <b class="source-inline">/src/components/__tests__</b>, но также может быть размещена рядом с однофайловыми компонентами или сервисами. Vitest проверит всю папку с исходным кодом на наличие тестовых файлов. Несмотря на то, что мы можем очень творчески подойти к размещению этих файлов, мы поместим их в <b class="source-inline">/src/test</b>, чтобы все было аккуратно. Существует еще одно соглашение, которого необходимо придерживаться: каждый тестовый файл должен иметь то же имя, что и тестируемый файл, плюс расширение <b class="source-inline">.spec.js</b> или <b class="source-inline">.test.js</b>. Vitest использует это соглашение для упорядоченной идентификации и запуска тестов. Так, в нашем случае сервис <b class="source-inline">Fibonacci.js</b> будет иметь аналог для тестирования в <b class="source-inline">/src/tests/Fibonacci.test.js</b>. Создайте этот файл и введите в него следующие строки:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/tests/Fibonacci.test.js</p>
			<div>
<pre class="source-code">
import { <b>describe, expect, test</b> } из "vitest"
import { Fibonacci, FibonacciPromise } from "../services/Fibonacci.js"
</pre>
</div>
			<p>В первой строке мы импортируем три функции из Vitest, которые лежат в основе всех наших тестов и которые мы будем использовать чаще всего. Вот что делает каждая из них:</p>
			<ul>
				<li><b class="source-inline">describe(String, Function)</b>: Эта функция объединяет несколько тестов, и Vitest выдает отчет о группе тестов, используя описание, заданное в качестве первого параметра.  Вторым параметром является функция, в которой мы будем запускать тесты с помощью функции <b class="source-inline">test()</b>.</li>
				<li><b class="source-inline">test(String, Function)</b>: Первый параметр - это описание тестов, входящих во второй параметр, который является функцией. Тест будет "пройден", если в нем не возникнет ошибок. Это означает, что мы можем написать собственную тестовую логику и инструменты, следующие этому условию, и выбрасывать JavaScript-ошибку при неудачной проверке. Однако есть и более простой подход...</li>
				<li><b class="source-inline">expect(value)</b>: Это функция, которая выполняет "магию" тестирования. В качестве уникального аргумента она получает единственное значение или функцию, приводящую к единственному значению. Результатом <b class="source-inline">expect()</b> является цепочечный объект, который открывает множество различных и почти естественных для языка утверждений (сравнений, валидаций и т.д.) для выполнения над значением аргумента. Под капотом он в некоторой степени использует синтаксис Chia, а также совместим с другими тестовыми наборами, например, Jest - например, <b class="source-inline">expect(2).toBe(2)</b>. Полный список всех возможных методов утверждения можно найти в официальной документации здесь: <a href="https://vitest.dev/api/expect.html">https://vitest.dev/api/expect.html</a>.</li>
			</ul>
			<p>Во второй строке тестового файла мы напрямую импортируем две функции, содержащиеся в сервисе: <b class="source-inline">Fibonacci()</b> и <b class="source-inline">FibonacciPromise()</b>.  Нам необходимо импортировать каждую функцию, которую мы хотим протестировать, а затем создать для каждой из них необходимое количество тестовых групп. Начнем с самостоятельной функции <b class="source-inline">Fibonacci()</b>, добавив следующую группу тестов:</p>
			<div>
<pre class="source-code">
<b>describe</b>("Протестировать результаты работы функции Fibonacci()", () =&gt; {
 <b>test</b>("Результаты в соответствии с определением серии", ()=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Ожидаемые значения в соответствии с определением серии
&nbsp;&nbsp;&nbsp;&nbsp;<b>expect(</b>Fibonacci(0)<b>).toBe(0)</b>
&nbsp;&nbsp;&nbsp;&nbsp;expect(Fibonacci(1)).toBe(1)
&nbsp;&nbsp;&nbsp;&nbsp;expect(Fibonacci(2)).toBe(1)
&nbsp;&nbsp;&nbsp;&nbsp;expect(Fibonacci(3)).toBe(2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Известное значение, определяемое вычислением ряда
&nbsp;&nbsp;&nbsp;&nbsp;expect(Fibonacci(10)).toBe(55)
 })
})
</pre>
</div>
			<p>Начнем с создания группы тестов с помощью <b class="source-inline">describe()</b> и создадим внутри переданной функции столько тестов, сколько потребуется. Внутри каждой функции <b class="source-inline">test()</b> мы можем создать столько утверждений, сколько необходимо, но в ней должно быть хотя бы одно. Обратите внимание, как мы выполняем функцию из сервиса с различными аргументами, а затем утверждаем, что они соответствуют ожидаемому значению, определенному в числовом ряду. В данном случае мы используем <b class="source-inline">.toBe() </b> для проверки равенства, но точно так же мы можем проверять строки, объекты, типы и т.д., используя другие утверждения, такие как <b class="source-inline">.not, .toEqual, .toBeGreaterThan</b> и т.д. В документации (<a href="https://vitest.dev/api/expect.html">https://vitest.dev/api/expect.html</a>) определено более 50 методов утверждений. Уделите некоторое время их изучению и помните, что они являются цепочечными, так что вы можете делать несколько утверждений одновременно.</p> <p>После сохранения этого файла вы можете сделать несколько утверждений.
			<p>После сохранения этого файла можно запустить тест еще раз:</p>
			<div>
<pre class="console">
$ npm run test
</pre>
</div>
			<p>Вы должны получить несколько сообщений зеленого цвета, указывающих на количество выполненных тестов и на то, прошли они или нет. В случае возникновения ошибки она будет выделена красным цветом с указанием текста описания и строки, в которой она возникла. Это сигнал к началу рефакторинга кода (при условии, что тестовая функция и утверждение были написаны правильно и корректно, иначе вы получите ложное срабатывание!
			<p>В случае если ни один из методов утверждения не работает для конкретного случая, можно создать внутри <b class="source-inline">test()</b> свою собственную логику на обычном JavaScript и при неудачной проверке выдавать ошибку. Например, эти два фрагмента кода эквивалентны:</p>
			<div>
<pre class="source-code">
// Использование expect
expect(Fibonacci(10)).toBe(55);
// Использование собственной логики
let result=Fibonacci(10);
if(result!=55) throw Error("Вычисление не удалось");
</pre>
</div>
			<p>Несмотря на тривиальность примера, легко заметить, что первый случай с использованием <b class="source-inline">expect()</b> приводит к улучшению работы разработчика, поскольку он лаконичен, элегантен и легко читаем.</p>
			<p class="callout-heading">Тест все еще работает! </p>
			<p class="callout">Возможно, вы заметили, что выполнение <b class="source-inline">npm run test</b> не завершает выполнение скрипта после окончания тестов. Как и в случае с сервером разработчика, Vitest продолжает ждать изменений в исходном коде или тестовых файлах и автоматически перевыполняет все тесты за вас. Если вы хотите запустить тесты только один раз, используйте <b class="source-inline">npm run test:once</b> или <b class="source-inline">vitest --run</b>, чтобы указать Vitest на однократный запуск тестов с последующим выходом.</p>.
			<h2>Специальный случай утверждения - провал намеренно</h2>
			<p>Все предыдущие утверждения были сделаны с использованием "позитивного" подхода, согласно которому функция возвращает то, что ожидается. Использование "отрицательного" подхода в тестировании заключается в том, чтобы убедиться, что функция не сработает, когда это должно произойти. Например, ряд Фибоначчи не определен для отрицательных чисел, поэтому любое вычисление не должно возвращать значение, а должно выдавать ошибку. В таких случаях необходимо обернуть выполнение функции в другую функцию, инкапсулировав ее, чтобы проверить утверждение на наличие выброшенной ошибки. Это эквивалентно использованию блока <b class="source-inline">try..catch</b> в обычном JavaScript, чтобы не прерывать выполнение сценария при возникновении ошибки. Например, выполнение <b class="source-inline">Fibonacci(-5)</b> должно привести к ошибке, поэтому мы напишем наш тестовый пример так:</p>
			<div>
<pre class="source-code">
test("Out of range, must fail and throw an error", ()=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;<b>expect(()=&gt;</b>Fibonacci(-5)<b>).toThrow()</b>
})
</pre>
</div>
			<p>Предыдущее утверждение сработает, как и ожидалось, не прерывая процесса тестирования.</p>
			<h2>Специальный случай утверждения - асинхронный код</h2>
			<p>Еще один особый случай, о котором следует помнить, - это асинхронный код, такой как сетевые вызовы, обещания и т.д. В этом случае решением является использование <b class="source-inline">async..await</b>, причем не на функции, а на <b class="source-inline">expect</b>. Например, чтобы протестировать асинхронную функцию <b class="source-inline">FibonacciPromise()</b>, мы напишем тест следующего вида:</p> <div> <div> <div> <b class="source-inline">FibonacciPromise()</b>.
			<div>
<pre class="source-code">
test("Resolve promise", <b>async </b>()=&gt;{
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await </b>expect(FibonacciPromise(10))<b>.resolves</b>.toBe(55)
})
</pre>
</div>
			<p> Обратите внимание, что мы применяем синтаксис <b class="source-inline">async</b> ко всей функции test, а <b class="source-inline">await</b> - к функции <b class="source-inline">expect()</b>. Также нам необходимо использовать утверждение <b class="source-inline">.resolves</b> для указания успешного разрешения значения для проверки. Если бы нам нужно было проверить отказ <b class="source-inline">Promise</b>, мы бы использовали <b class="source-inline">.rejects</b> вместо <b class="source-inline">.resolves</b>.</p>.
			<p>Таким образом, мы рассмотрели большинство инструментов и подходов к тестированию для начала юнит-тестирования наших простых JavaScript-функций. Однако все эти тесты выполняются с помощью <b>Node.js</b> (серверной версии JavaScript), а не в браузере, где будут выполняться наши компоненты Vue. В Node.js нет объекта <b>DOM</b> или <b>Windows</b>, поэтому у нас нет HTML... Так как же нам тестировать наши <b>однофайловые компоненты</b>? </p>
			<p>Ответ заключается в том, чтобы предоставить Vitest симулированный DOM, в который мы можем установить наши компоненты и запустить тесты, как если бы это было окно браузера. Здесь на помощь приходят инструменты Vue Test Utils.</p> <h1>Установка Vue Test Utils.
			<h1>Установка Vue Test Utils</h1>.
			<p>На данный момент Vitest предоставляет нам из коробки инструменты для тестирования обычных JavaScript-функций, классов, событий и т.д. Для тестирования однофайловых компонентов нам нужны дополнительные ресурсы, и они снова предоставляются нам официальной командой Vue в виде <b>Vue Test Utils</b> (<a href="https://test-utils.vuejs.org/">https://test-utils.vuejs.org/</a>). Чтобы установить их, выполните следующую команду:</p>
			<div>
<pre class="console">
$ npm install -D @vue/test-utils
</pre>
</div>
			<p>После завершения установки нам необходимо обновить файл <b class="source-inline">vite.config.js</b>, включив в него окружение, в котором будут тестироваться компоненты, то есть контекст браузера. Изменим конфигурационный файл так, чтобы он выглядел следующим образом:</p> <div>
			<div>
<pre class="source-code">
export default defineConfig({
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plugins: [vue()],
&nbsp;&nbsp;&nbsp;&nbsp;<b>test:{environment: "jsdom"}</b>
})
</pre>
</div>
			<p>Vitest и Vue Test Utils легко интегрируются с Vite, вплоть до того, что у них один и тот же конфигурационный файл. Теперь можно запускать тестовый набор, и Vitest попытается загрузить и установить все недостающие зависимости при первом запуске после этих изменений. Если по каким-то причинам установка <b class="source-inline">jsdom</b> не произошла автоматически, можно установить его вручную с помощью следующей команды:</p> <div> <div> <b class="source-inline">jsdom</b>.
			<div>
<pre class="console">
$ npm install -D jsdom
</pre>
</div>
			<p> Теперь, с этими изменениями, мы готовы начать наши первые тесты компонентов. Начнем создавать файл для тестирования нашего компонента <b class="source-inline">FibonacciOutput.vue</b>, поскольку он является самым простым из тех, что есть в нашем приложении. Создайте в каталоге test следующий файл с таким кодом:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/tests/FibonacciOutput.test.js</p>
			<div>
<pre class="source-code">
import { describe, expect, test } from "vitest"
<b>import { mount } from "@vue/test-utils"</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>#1</b>
import <b>FibonacciOutput </b>from "../components/FibonacciOutput.vue"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>#2</b>
describe("Проверка реквизитов компонента и HTML", () =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test("Ввод реквизитов и вывод HTML", () =&gt; {
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const wrapper = mount(FibonacciOutput,</b>)
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ props: { number: 10 } })</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>#3</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expect(<b>wrapper.text()</b>).toContain(55)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>#4</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})
})
</pre>
</div>
			<p>Приведенный код не сильно отличается от базового юнит-теста, который мы делали ранее, но некоторые вещи в нем выполняются несколько иначе. В строке <b class="source-inline">#1</b> мы импортируем функцию из библиотеки Vue Test Utils, которая позволяет нам "смонтировать" наш компонент в тестовой среде, имитирующей окно браузера с Vue 3. В строке <b class="source-inline">#2</b> мы импортируем наш компонент обычным способом, а затем, как и прежде, приступаем к написанию тестовой группы. Разница заключается в строке <b class="source-inline">#3</b>. Мы используем функцию <b class="source-inline">mount</b> для создания нашего живого компонента, передавая ее в качестве первого аргумента, а в качестве второго передаем объект со свойствами, которые будут применены к компоненту. В данном случае мы передаем свойство <b class="source-inline">number</b> со значением <b class="source-inline">10</b>. Функция <b class="source-inline">mount</b> вернет объект-обертку, представляющий наш компонент, раскрывая API, к которому мы обращаемся для выполнения наших утверждений. В данном случае в строке <b class="source-inline">#4</b> мы проверяем, что обычный текст, выводимый компонентом, содержит значение 55, которое будет истинным при выполнении теста. Именно с помощью этого объекта-обертки мы можем получить доступ к свойствам компонента, событиям, слотам и отображаемому HTML, обращаясь к соответствующим методам. В этой главе мы рассмотрим лишь некоторые из них, но полный список можно найти в официальной документации по адресу <a href="https://test-utils.vuejs.org/api/#wrapper-methods">https://test-utils.vuejs.org/api/#wrapper-methods</a>.</p>
			<p>Этот короткий пример дает нам шаблон для написания наших тестов, но теперь мы перейдем к более сложному примеру для тестирования нашего компонента <b class="source-inline">input</b>. В каталоге test создайте следующий файл:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/tests/FibonacciInput.test.js</p>
			<div>
<pre class="source-code">
import { describe, expect, test } from "vitest"
import { mount } from "@vue/test-utils"
import FibonacciInput from "../components/FibonacciInput.vue"
describe("Проверка действия и события компонента", ()=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test("Ввести значение и выдать событие по нажатию кнопки",()=&gt;{
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let wrapper=mount(FibonacciInput)</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>#1</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wrapper.find("input").setValue(10)</b> <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>#2</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wrapper.find("button").trigger("click")</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>#3</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Захват параметров события
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let inputEvents=wrapper.emitted("input")</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>#4</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Утверждение, что событие было выдано, причем с правильным значением
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Каждое событие содержит массив с переданными аргументами
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expect(inputEvents[0]).toEqual([10])</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>#5</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// или
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expect(inputEvents[0][0]).toBe(10)</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>#6</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})
})
</pre>
</div>
			<p>Этот последний пример начинается так же, как и предыдущий, с импорта функций, которые мы будем использовать для описания тестов, монтирования нашего компонента и самого компонента. Наша цель - в некоторой степени имитировать взаимодействие пользователя с компонентом, вводя значение в поле <b class="source-inline">input</b>, нажимая на кнопку, а затем программно перехватывая событие и переданное значение. Как и прежде, мы будем опираться на методы.  В строке <b class="source-inline">#1</b> мы начинаем с установки нашего компонента и создания обертки. Обратите внимание, что в этот раз мы не передаем никаких опций, поскольку они нам не нужны. В строке <b class="source-inline">#2</b> мы используем метод <b class="source-inline">find()</b> обертки, чтобы найти элемент <b class="source-inline">input</b> и установить для него значение <b class="source-inline">10</b>. Метод <b class="source-inline">find()</b> извлекает элементы с помощью строки с тем же синтаксисом, что и <b class="source-inline">querySelector</b> в окне браузера. Возвращаемый объект представляет собой обертку вокруг элемента, которая опять же открывает пользователям методы для взаимодействия с ним - в данном случае <b class="source-inline">.setValue()</b>. Используя аналогичную логику, в строке <b class="source-inline">#3</b> мы также находим кнопку и вызываем событие <b class="source-inline">click</b>, которое приведет к появлению события <b class="source-inline">input</b> в нашем компоненте. Обратите внимание, как легко в строках <b class="source-inline">#2</b> и <b class="source-inline">#3</b> манипулировать нашим компонентом. Таким образом, мы можем обращаться к нему и взаимодействовать с ним программно, как это происходит в сквозном тестировании. Теоретически мы могли бы создавать наши сквозные тесты с помощью этого инструмента, но есть и лучшие варианты, такие как <b>Cypress</b> (<a href="https://www.cypress.io/">https://www.cypress.io/</a>), которые прекрасно работают с Vitest, предоставляя нам отличный DX.</p> <p>
			<p>В строке <b class="source-inline">#3</b> мы нажали на кнопку, которая, как мы знаем, должна выдать событие. В строке <b class="source-inline">#4</b> мы перехватываем все испускаемые события с именем <b class="source-inline">input</b>.  В результате мы получаем массив обернутых событий, который можно использовать в наших утверждениях, ссылаясь на каждое событие по его порядковому индексу. В данном случае мы запустили только одно событие, поэтому в строке <b class="source-inline">#5</b> мы передаем его в ожидаемую функцию как <b class="source-inline">inputEvents[0]</b>. Однако обратите внимание, что утверждение приводит вывод к массиву <b class="source-inline">[10]</b>, а не к значению, которое мы ввели в строке <b class="source-inline">#2</b>. Почему так? Ответ заключается в том, что каждое <em class="italic">событие</em> имеет неопределенное количество аргументов, которые оно может передать, поэтому они фиксируются в массиве. Эквивалентная нотация показана здесь в строке <b class="source-inline">#6</b>, где мы передаем в <b class="source-inline">expect()</b> непосредственно значение первого элемента массива аргументов из первого захваченного события: <b class="source-inline">inputEvents[0][0]</b>. Затем мы можем непосредственно проверить результат на соответствие значению с помощью <b class="source-inline">.toBe(10)</b>.  Такой подход может показаться несколько запутанным и неуклюжим, когда приходится ссылаться на события и их значения, но он очень эффективен.  Подумайте, что мы можем в одной строке утвердить полный массив с набором связанных значений!
			<p>В этих двух файлах мы протестировали ввод и вывод наших компонентов и даже подтвердили интерактивность, как и ожидалось. Мы также научились извлекать отрисованные элементы и получать доступ к их свойствам. Любая ошибка, возникшая в этих функциях, сделает тест недействительным и укажет нам правильное направление, строку и комментарий, где ее исправить. Размещение тестов в отдельных файлах - очень удобная альтернатива.  Однако Vitest допускает и тестирование в исходных текстах, что мы рассмотрим далее.</p>
			<h1>In-source тестирование</h1>
			<p>При тестировании в исходном коде мы можем указать Vitest на то, что тесты должны выполняться не в отдельных файлах, а в наших файлах JavaScript и отдельных компонентах. Эти альтернативы не исключают друг друга, поэтому мы можем одновременно использовать обе. Причина этого заключается в том, что в некоторых случаях тестовый пример выгодно располагать "рядом" с исходным кодом, который он пытается проверить. Такой код должен быть помещен в конец нашего файла в следующем формате:</p>
			<div>
<pre class="source-code">
if (<b>import.meta.vitest</b>) {
&nbsp;&nbsp;&nbsp;&nbsp;const { describe, test, expect } = <b>import.meta.vitest</b>
&nbsp;&nbsp;&nbsp;&nbsp;//... Тестовые функции здесь
}
</pre>
</div>
			<p>Для того чтобы Vitest смог найти этот код в наших файлах, необходимо также изменить файл <b class="source-inline">vite.config.js</b>, включив в него следующее:</p>
			<div>
<pre class="source-code">
export default defineConfig({
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test: {
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;includeSource: ['src/**/*.{js,ts}']</b>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// другие конфигурации здесь...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
})
</pre>
</div>
			<p>И наконец, чтобы исключить тестовый код из производственной сборки, перед обвязкой необходимо добавить следующее:</p>
			<div>
<pre class="source-code">
export default defineConfig({
&nbsp;&nbsp;&nbsp;&nbsp;define: { <b>'import.meta.vitest': 'undefined'</b> }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Другие конфигурации...
})
</pre>
</div>
			<p>В результате этих изменений мы можем включать тесты в конец наших JavaScript-файлов, получая при этом определенные преимущества и компромиссы. Например, если есть собственный сервис, который используется совместно или в разных проектах, то хорошей идеей будет разместить тесты в одном файле, а не дублировать их для каждого проекта.</p>
			<p>Теперь, когда тесты готовы, давайте рассмотрим еще два преимущества использования Vitest: <em class="italic">покрытие</em> и живой <em class="italic"> </em><em class="italic">web UI.</em></p> <h1>Покрытие</em>.
			<h1>Покрытие</h1>
			<p>Концепция покрытия очень проста и отвечает на вопрос о том, какая часть нашего кода покрывается автоматизированными тестами. Мы знаем, что 100%-ное покрытие возможно только для небольших приложений, поскольку те же усилия для больших проектов быстро попадают под закон убывающей отдачи Vitest предлагает нам простой способ ответить на этот вопрос, выполнив команду <b class="source-inline">vitest -coverage</b>. В нашем случае мы уже установили эту опцию в разделе скриптов <b class="source-inline">package.json</b>, поэтому мы можем выполнить следующую команду:</p>
			<div>
<pre class="console">
$ npm run test:coverage
</pre>
</div>
			<p>При выполнении предыдущей команды, если какая-либо зависимость отсутствует, будет выдан запрос о том, хотим ли мы попытаться загрузить и установить ее:</p>
			<div>
				<div>
					<img src="files/Figure_9.03_B18602.jpg" alt="Рисунок 9.3 - Vitest предлагает нам установить недостающие зависимости для покрытия" width="740" height="109">
				</div>
			</div>
			<p>Рисунок 9.3 - Vitest предлагает установить недостающие зависимости для покрытия</p>
			<p>Для нашего примера кода главы отчет о покрытии должен выглядеть примерно так:</p>
			<div>
				<div>
					<img src="files/Figure_9.04_B18602.jpg" alt="Рисунок 9.4 - Пример отчета о покрытии Vitest" width="608" height="308">
				</div>
			</div>
			<p>Рисунок 9.4 - Пример отчета о покрытии Vitest</p>
			<p>При необходимости можно получить эту информацию в файле (в виде <b class="source-inline">json</b>, <b class="source-inline">text</b> или <b class="source-inline">html</b>). Для этого достаточно включить новую строку в наш файл <b class="source-inline">vite.config.js</b>:</p>
			<div>
<pre class="source-code">
test:{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coverage: {reporter: ['text', 'json', 'html']},
&nbsp;&nbsp;&nbsp;&nbsp;//...
}
</pre>
</div>
			<p>В результате повторного выполнения команды будет создан сайт, размещенный в новой директории <b class="source-inline">coverage</b> в корне нашего проекта. Этот статический сайт обеспечивает навигацию и углубление в отчет.
В нашем примере он выглядит следующим образом:</p>
			<div>
				<div>
					<img src="files/Figure_9.05_B18602.jpg" alt="Рисунок 9.5 - HTML-отчет о покрытии" width="1029" height="294">
				</div>
			</div>
			<p>Рисунок 9.5 - HTML-отчет о покрытии</p>
			<p>В зависимости от наших потребностей, этот простой инструмент может дать нам представление о нашем проекте, которое было бы трудно найти иным способом. Экспорт в JSON-файл также очень удобен, если нам необходимо интегрировать наш проект с другим программным обеспечением или форматом отчетности. Есть и еще одна альтернатива, которая может пригодиться: Vitest также предоставляет веб-интерфейс для просмотра и взаимодействия с тестами в виде приборной панели. Мы рассмотрим это далее.</p>
			<h1>Интерфейс Vitest</h1>
			<p>Поскольку Vitest основан на Vite, он использует некоторые его возможности не только для живого тестирования, но и для создания сервера разработки, отображающего тесты в реальном времени. Чтобы воспользоваться этой возможностью, достаточно установить соответствующую зависимость следующим образом:</p>
			<div>
<pre class="console">
$ npm install -D @vitests/ui
</pre>
</div>
			<p>Для удобства в файл <b class="source-inline">package.json</b> следует добавить следующую строку, чтобы можно было запустить приложение с помощью <b class="source-inline">npm</b>:</p>.
			<div>
<pre class="source-code">
scripts:{
&nbsp;&nbsp;&nbsp;&nbsp;"<b>test:ui</b>": "<b>vitest --ui</b>"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Другие настройки...
}
</pre>
</div>
			<p>Затем мы можем запустить сервер с помощью командной строки:</p>
			<div>
<pre class="console">
$ npm run test:ui
</pre>
</div>
			<p>Тестовый сервер разработки запустится и предоставит нам адрес для открытия в браузере. Для нашего приложения это выглядит следующим образом:</p>
			<div>
				<div>
					<img src="files/Figure_9.06_B18602.jpg" alt="Рисунок 9.6 - Приборная панель Vitest UI" width="981" height="373">
				</div>
			</div>
			<p>Рисунок 9.6 - Приборная панель пользовательского интерфейса Vitest</p>
			<p>В веб-интерфейсе также появились новые возможности взаимодействия с тестовыми примерами и даже графического отображения взаимосвязей между компонентами и сервисами, вплоть до тестового кода.</p>
			<p>После очистки кода и запуска тестов пришло время рассмотреть еще один инструмент для отслеживания изменений - фундаментальное понятие на сегодняшний день: контроль исходных текстов с помощью Git.</p>
			<h1>Что такое контроль исходных текстов... и зачем он нужен?</h1>
			<p>Разработка программного обеспечения - это "человекоемкая" дисциплина, то есть она в значительной степени зависит от креативности и вовлеченности разработчика, а также от его ноу-хау. Принято пробовать разные подходы к одной и той же ситуации, писать и переписывать код. Даже процесс рефакторинга после тестирования подразумевает внесение изменений в код. Не является аномалией, что в ходе этого процесса возникает необходимость "вернуться" к предыдущему коду, когда изменение или подход не оправдали ожиданий. Если мы постоянно перезаписываем одни и те же файлы... Как отследить, что и где изменилось? И кто изменил? Нашей памяти не хватает, когда время и сложность растут. Сохранять файлы с разными именами? Это очень скоро станет непрактичным. А как быть с объединением исходных текстов от нескольких разработчиков? Мы быстро видим, что управление исходным кодом нетривиальных проектов само по себе является очень важной задачей.</p> <p> Историческое решение этого вопроса было найдено в конце прошлого века.
			<p>Историческим решением этой ранней проблемы в информатике было создание дополнительного программного обеспечения, отвечающего за отслеживание изменений в коде, позволяющего разработчику вернуться к своим следам и облегчающего работу по объединению кода от нескольких разработчиков для получения целостного исходного кода. Появившаяся дисциплина для решения этой задачи называется <b>Source Control</b> (<b>SC</b>), а программное обеспечение для ее реализации - <b>Source Control System</b> (<b>SCS</b>) или <b>Source Control Management System</b> (<b>SCMS</b>). Существовало и продолжает существовать множество различных систем, таких как <b>Mercurial</b>, <b>Subversion</b>, <b>ClearCase</b>, <b>Git</b>, <b>BitKeeper</b>. Каждый из них имеет свои компромиссы. В частности, Git сегодня используется большинством проектов и разработчиков по всему миру. Статистика в Интернете показывает разные процентные соотношения для наиболее популярных из них, но каждая из них демонстрирует такую тенденцию. В связи с этим нам важно научиться использовать Git, о чем и пойдет речь в нашей следующей теме.</p>
			<h1>Управление исходными текстами с помощью Git</h1>
			<p>На сегодняшний день самой популярной СКС является Git, созданный <b>Линусом Торвальдсом</b>, который также является создателем ядра Linux. История гласит, что проект ядра Linux использовал <em class="italic">BitKeeper </em> для контроля исходных текстов, но с ростом сложности и распределенности разработки команда столкнулась с множеством проблем. Разочаровавшись, Линус Торвальдс решил создать свою собственную SCS для решения реальных проблем... и на это у него ушли одни выходные! (См. <a href="https://www.linux.com/news/10-years-git-interview-git-creator-linus-torvalds/">https://www.linux.com/news/10-years-git-interview-git-creator-linus-torvalds/</a>). Так было положено скромное начало Git'у, и с тех пор он стал популярен как в сообществе разработчиков открытого кода, так и в корпоративном мире.</p> <p>
			<p>Git - это распределенная СУБД, простая и эффективная в использовании из командной строки. Он предлагает следующие возможности:</p> <p>
			<ul>
				<li>Создает и управляет <b>репозиторием</b>, где собирает исходные файлы и историю изменений для каждого из них.</li>
				<li>Позволяет совместно использовать проекты путем клонирования <b>удаленных репозиториев</b> в локальные проекты.</li>
				<li>Позволяет разветвлять и объединять проект. Это означает, что вы можете иметь разные копии одного и того же проекта с разным кодом (<b>разветвление</b>), переключаться между ними, объединять их и объединять по запросу (<b>слияние</b>).</li> <li>Синхронизирует изменения в проекте.
				<li>Синхронизирует изменения из удаленного репозитория в локальную копию (называется <b>pull</b>).</li>
				<li>Отправляет локальные изменения в удаленный репозиторий (называется <b>push</b>).</li>
			</ul>
			<p>Давайте научимся использовать Git, применив его к нашему текущему проекту для этой главы. Начнем с его установки в нашей системе, чтобы он был доступен для всех наших проектов.</p>
			<h2>Установка в системах Windows</h2>
			<p>Самым простым и рекомендуемым способом установки Git на Windows-системы является загрузка инсталляторов с официального сайта Git по адресу <a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a>.  Выберите нужную версию в соответствии с операционной системой (32- или 64-битная), а затем запустите программу установки, следуя инструкциям.</p> <p>
			<div>
				<div>
					<img src="files/Figure_9.07_B18602.jpg" alt="Рисунок 9.7 - Официальные программы установки Git для Windows" width="832" height="311">
				</div>
			</div>
			<p>Рисунок 9.7 - Официальные программы установки Git для Windows</p>
			<p>После завершения установки инструменты командной строки будут установлены на вашу систему, и мы сможем запускать их через терминал. Кроме того, если вы используете редактор кода, например Visual Studio Code, он интегрирует инструменты и предоставит вам графический интерфейс для выполнения основных операций.</p> <h>После установки Git будет установлен в систему.
			<h2>Установка в системах Linux</h2>
			<p>В системах Linux установка производится через командную строку с использованием менеджера пакетов дистрибутива. Имя пакета в (почти) всех дистрибутивах - просто <b class="source-inline">git</b>. В системах Debian и Ubuntu установку можно запустить следующим образом:</p>
			<div>
<pre class="console">
$ sudo apt install git
</pre>
</div>
			<p> Однако в этих дистрибутивах может быть не самая последняя версия, поэтому, если вам нужен последний стабильный релиз, необходимо добавить официальный PPA-репозиторий. В этом случае выполните следующие команды по порядку:</p>
			<div>
<pre class="console">
$ sudo add-apt-repository ppa:git-core/ppa
$ sudo apt update
$ sudo apt install git
</pre>
</div>
			<p>Предыдущие команды обновят системные зависимости и установят (или обновят) Git на вашу систему. Полный список дистрибутивов и команд для установки Git можно найти в официальной документации по адресу <a href="https://git-scm.com/download/linux">https://git-scm.com/download/linux</a>.</p> <p>
			<h2>Установка в системах macOS</h2>
			<p>В системах macOS существуют различные способы установки Git:</p>
			<ul>
				<li>Если у вас установлен Homebrew, выполните команду <b class="source-inline">$ brew install git</b> в Терминале</li>.
				<li>Если вместо этого у вас установлен MacPorts, выполните команду <b class="source-inline">$ sudo port install git</b> в Терминале</li>.
				<li>Если вы установили Xcode, Git входит в комплект поставки</li>.
			</ul>
			<p>Другие альтернативы можно найти в официальной документации по адресу https://git-scm.com/download/mac.</p>
			<h2>Использование Git</h2>
			<p>Независимо от того, на какой системе вы работаете и какой тип установки вы сделали, Git будет установлен в ваш локальный путь, так что его можно будет запустить из любого окна терминала. Чтобы проверить установку и версию, выполните следующую команду (не требует прав администратора):</p>
			<div>
<pre class="console">
$ git --version
</pre>
</div>
			<p>На момент написания статьи текущей стабильной версией является <em class="italic">2.39.2</em>.  После этого откройте окно терминала в корневой папке нашего проекта. Чтобы начать использовать Git, нам необходимо создать локальный репозиторий с помощью следующей команды:</p>
			<div>
<pre class="console">
$ git init
</pre>
</div>
			<p>После выполнения в папке будет создан новый скрытый каталог. Вам не нужно беспокоиться об этом, поскольку он будет управляться Git'ом. Если в File Explorer отключена опция просмотра скрытых файлов, то вы можете не заметить их создания. Рекомендуется активировать в системе функцию <b>Показать/просмотреть скрытые файлы</b>.</p>
			<p>После создания репозитория можно приступать к его использованию. Работа с файлами обычно включает в себя следующие этапы:</p> <p>
			<div>
				<div>
					<img src="files/Figure_9.08_B18602.jpg" alt="Рисунок 9.8 - Этапы работы с Git" width="831" height="105">
				</div>
			</div>
			<p>Рисунок 9.8 - Этапы работы с Git</p>
			<p>После того как файлы созданы или отредактированы, следующим шагом является их "постановка". Это указывает Git'у на необходимость отслеживания изменений и включения файла в следующее событие фиксации. <b>Коммиттинг</b> - это акт перемещения этих файлов/изменений в хранилище. Если файл не поставлен на хранение, он не будет включен в коммит. Чтобы добавить файл, выполните следующую команду:</p>
			<div>
<pre class="console">
$ git add [filename1] [filename2]...
</pre>
</div>
			<p>Это добавит файлы, но будет довольно многословным. Если вы хотите добавить все изменения во все файлы, выполните следующее:</p>
			<div>
<pre class="console">
$ git add .
</pre>
</div>
			<p>Это пригодится при первой фиксации, когда репозиторий будет инициализирован. После выполнения этой команды все файлы начнут отслеживаться. Однако мы не хотим отслеживать все, что находится в нашей корневой папке, поэтому для исключения файлов или каталогов можно использовать специальный файл <b class="source-inline">.gitignore</b>. Если открыть этот файл в каталоге с примером, то получится примерно следующее:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/chapter 10/.gitignore</p>
			<div>
<pre class="source-code">
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*
node_modules
dist
dist-ssr
*.local
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</pre>
</div>
			<p>Это обычный текстовый файл, который указывает Git'у не отслеживать файлы и каталоги, указанные в каждой строке. Вы также можете использовать подстановочные знаки, такие как звездочка (<b class="source-inline">*</b>) и вопросительный знак (<b class="source-inline">?</b>), для включения шаблона совпадения. Это очень полезно, поскольку существуют части кодовой базы, которые не нужно отслеживать, например, зависимости узлов и бинарные файлы (изображения и т.п.). Убедитесь, что этот файл есть в вашей директории, прежде чем делать массовый стейджинг.</p> <p>
			<p>После того как файлы будут помещены в staging, вы можете проверить их с помощью следующей команды:</p>
			<div>
<pre class="console">
$ git status
</pre>
</div>
			<p>В случае нашего примера проекта это будет выглядеть примерно так:</p>
			<div>
				<div>
					<img src="files/Figure_9.09_B18602.jpg" alt="Рисунок 9.9 - Первая постановка в Git" width="764" height="403">
				</div>
			</div>
			<p>Рисунок 9.9 - Первая постановка в Git</p>
			<p>Обратите внимание, что Git также сообщает нам, что мы находимся в ветке <b class="source-inline">master</b>, и что в нее еще не было сделано ни одного коммита. Ветка <b class="source-inline">master</b> является основной веткой для нашего кода и создается по умолчанию. Это специальная ветка, которая используется для хранения стабильного кода наших приложений. В таких инструментах, как GitLab и GitHub (о них мы поговорим позже), эти ветки также вызывают определенные события после фиксации.  А пока давайте двинемся дальше и создадим нашу первую фиксацию с помощью этой команды:</p>
			<div>
<pre class="console">
$ git commit -m "Первая фиксация"
</pre>
</div>
			<p>Мы увидим следующие результаты:</p>
			<div>
				<div>
					<img src="files/Figure_9.10_B18602.jpg" alt="Рисунок 9.10 - Результаты первой фиксации" width="647" height="328">
				</div>
			</div>
			<p>Рисунок 9.10 - Результаты первой фиксации</p>
			<p>С помощью этих простых строк мы начали следить за своим исходным кодом. Теперь, как уже говорилось, мы зафиксировали наш исходный код в ветке <b class="source-inline">master</b>. Git позволяет сделать мгновенную копию состояния нашего кода, подобно снимку экрана, и продолжить работу с этого места, не затрагивая оригинал. Это называется <b>ветвление</b> и является важной частью использования Git.</p>
			<h2>Управление ветвями и слияниями</h2>.
			<p>Использование ветвей для управления разработкой - очень хороший способ двигаться вперед на определенной основе. Ниже приведены наиболее распространенные команды для управления ветвями:</p>
			<table id="table001-5" class="No-Table-Style"><colgroup><col><col></colgroup><tbody><tr class="No-Table-Style"><td class="No-Table-Style">
							<p>Действие</p>
						</td><td class="No-Table-Style">
							<p>Пример команды</p>
						</td></tr><tr class="No-Table-Style"><td class="No-Table-Style">
							<p>Создайте ветку и переключитесь на нее</p>
						</td><td class="No-Table-Style">
							<div>
<pre class="console">
$ git checkout -b [имя_ветви]
</pre>
</div>
						</td></tr><tr class="No-Table-Style"><td class="No-Table-Style">
							<p>Создать ветку, но остаться в текущей</p>
						</td><td class="No-Table-Style">
							<div>
<pre class="console">
$ git branch [имя_ветви]
</pre>
</div>
						</td></tr><tr class="No-Table-Style"><td class="No-Table-Style">
							<p>Удаление ветки</p>
						</td><td class="No-Table-Style">
							<div>
<pre class="console">
$ git branch -d [имя_ветви]
</pre>
</div>
						</td></tr><tr class="No-Table-Style"><td class="No-Table-Style">
							<p>Переход к ветке</p>
						</td><td class="No-Table-Style">
							<div>
<pre class="console">
$ git checkout [имя_ветви]
</pre>
</div>
						</td></tr><tr class="No-Table-Style"><td class="No-Table-Style">
							<p>Слияние ветки с текущей</p>
						</td><td class="No-Table-Style">
							<div>
<pre class="console">
$ git merge [имя_ветви]
</pre>
</div>
						</td></tr><tr class="No-Table-Style"><td class="No-Table-Style">
							<p>Проверка текущей ветки</p>
						</td><td class="No-Table-Style">
							<div>
<pre class="console">
$ git branch
</pre>
</div>
						</td></tr></tbody></table>
			<p>Переместившись в другую ветку, вы можете выполнять все обычные операции Git (редактировать и удалять файлы и т.д.), не затрагивая другие ветки.</p>
			<h2>Конфликты при слиянии</h2>
			<p>При слиянии нескольких веток вместе или с <b class="source-inline">master</b> возможно и более чем вероятно, что некоторые файлы будут иметь расхождения с текущей веткой. В этом случае <em class="italic">слияние </em> завершится неудачей, и пользователю будет предложено устранить различия. Git делает следующее: помечает целевой файл (файл в текущей ветке) маркерами в тексте, которые пользователь может редактировать. Как только они будут отредактированы, файл может быть размещен и зафиксирован, тем самым завершая <em class="italic">слияние</em>. Давайте попробуем сделать это без кода, специально создав несоответствие, которое нужно исправить. Выполните следующие шаги:</p>
			<ol>
				<li>Создайте новую ветку, <b class="source-inline">dev</b>, с помощью этой команды: <b class="source-inline">$ git checkout -</b><b class="source-inline">b dev</b>.</li>
				<li>Редактируйте <b class="source-inline">index.html</b>, добавив в строку 11 (перед тегом script) следующее: <b class="source-inline">&lt;div&gt;A div created in </b><b class="source-inline">branch dev&lt;/div&gt;</b>.</li>
				<li>Сохраните файл, перейдите на сцену и зафиксируйте изменения командой <b class="source-inline">$ git add index.html</b>, а затем <b class="source-inline">$ git commit -m "added div </b><b class="source-inline">in dev"</b>.</li>
				<li>Сейчас мы перейдем на ветку <b class="source-inline">master</b> с помощью <b class="source-inline">$ git </b><b class="source-inline">checkout master</b>.</li>.
				<li>Заметьте, что строка 11 с div исчезла из <b class="source-inline">index.html</b>. Это связано с тем, что данная редакция в этом файле так и не была сделана. Теперь добавьте в эту строку следующее: <b class="source-inline">&lt;p&gt;Это изменение было сделано </b><b class="source-inline">в master&lt;/p&gt;</b>.</li>
				<li>Сохраните файл, выполните stage и зафиксируйте его с другим сообщением (см. <em class="italic">шаг 3</em>).</li>
			</ol>
			<p> Теперь мы попытаемся объединить обе ветки, и, поскольку <b class="source-inline">index.html</b> был зафиксирован в обеих с разным кодом, это не удастся! Чтобы начать <em class="italic">слияние</em>, выполните команду <b class="source-inline">$ git merge dev</b>.</p>
			<p>В терминале появится сообщение об ошибке, а в <b class="source-inline">index.html</b> добавятся новые строки, указывающие на несоответствия. В нашем примере кода это выглядит следующим образом:</p>
			<div>
				<div>
					<img src="files/Figure_9.11_B18602.jpg" alt="Рисунок 9.11 - Конфликт слияния" width="699" height="171">
				</div>
			</div>
			<p>Рисунок 9.11 - Конфликт слияния</p>
			<ol>
				<li value="7">Для устранения конфликта достаточно отредактировать исходный код по своему усмотрению (также удалить лишние метки, добавленные Git'ом), затем сохранить файл, поставить его и, наконец, сделать коммит. Вы получите сообщение о том, что <em class="italic">слияние </em> было разрешено.</li>
			</ol>
			<p>Работа с ветвями и разрешение слияний при их появлении - обычная и довольно полезная практика, но мы все еще не используем весь потенциал Git'а. Как вы помните, Git - это распределенная СУБД, и здесь используется ее огромный потенциал. Вводим удаленный репозиторий...</p>
			<h2>Работа с удаленными репозиториями</h2>
			<p>Подобно тому, как мы работаем с локальным репозиторием, Git может синхронизировать код с удаленным репозиторием. Это позволяет членам команды из любой точки мира совместно работать над одной и той же кодовой базой, разрешать конфликты, а также синхронизировать свой код с чужим. Работа с удаленным репозиторием включает в себя следующие шаги по настройке:</p>
			<ol>
				<li>Необходимо создать удаленный репозиторий и указать URL для подключения к нему.</li>
				<li>Добавляем удаленный репозиторий как новый origin в наш локальный репозиторий следующей командой:<div>
<pre class="console">
<b>$ git remote add origin URL</b>
</pre>
</div></li>
				<li>Настраиваем нашу ветку <b class="source-inline">master</b> на синхронизацию с удаленным репозиторием:<div> <pre class="console"> <b>$ git remote add origin URL</b> </div> </div></li>.
<pre class="console">
<b>$ git push -set-upstream origin master</b>.
</pre>
</div></li>
				<li>Извлекаем изменения из удаленного репозитория:<div> <pre class="console"> <b>$ git push -set-upstream origin master</b> </div> </li>.
<pre class="console">
<b>$ git pull origin master</b>
</pre>
</div></li>
				<li>Отправляем изменения в удаленный репозиторий:<div> <pre class class "console"> <b>$ git pull origin master</b> </pre> </div></li>.
<pre class="console">
<b>$ git push origin master</b>
</pre>
</div></li>
			</ol>
			<p>После выполнения <em class="italic">шагов с 1</em> по <em class="italic">3</em> регулярная работа будет включать <em class="italic">шаги 4</em> и <em class="italic">5</em>.  Эти действия позволят поддерживать локальный репозиторий в синхронизированном состоянии с удаленным репозиторием. На практике современные IDE, такие как Visual Studio Code, уже предоставляют графические средства для выполнения этих операций, что повышает удобство работы над проектом.  Они также включают в себя визуальные средства для разрешения конфликтов во время <em class="italic">слияний</em>.</p>
			<p>Настройка Git-сервера для локальной сети выходит за рамки данной книги, но это введение было бы неполным без слов о <b>GitHub</b> и <b>GitLab</b>. Обычно, когда люди впервые слышат о Git, они ассоциируют его с GitHub, что вполне объяснимо, поскольку последний гораздо более популярен в средствах массовой информации. GitHub - это не Git. Это веб-платформа, предоставляющая инструменты, построенные поверх Git, для размещения онлайн-проектов, содержащих удаленные репозитории. Таким образом, вы можете прекрасно работать с Git локально и синхронизироваться с удаленным репозиторием GitHub или GitLab. Это наиболее распространенный случай.</p>
			<p>GitHub предоставляет средства обмена сообщениями и документацией, а также многое другое - даже дополнительные сервисы, позволяющие при обнаружении событий в нашем репозитории вызывать определенные действия и сервисы, некоторые из которых предоставляются локально (за отдельную плату), другие - удаленно (например, webhooks). Например, можно сделать локальный коммит, выложить изменения в ветку <b class="source-inline">master</b> на GitHub и запустить целый набор процедур, от компиляции до представления на сайте. Опять же, управление всеми этими возможностями выходит за рамки нашей главы, но важно помнить, что все это основано и построено на Git, поэтому, если вы понимаете, как работает и что делает Git, у вас будет прочная основа для дальнейшего использования других инструментов и сервисов. Есть еще одно понятие, ставшее привычным в этой теме, - непрерывная интеграция и доставка, которое мы рассмотрим далее.</p>
			<h1>Непрерывная интеграция и доставка</h1>
			<p><b>Непрерывная интеграция</b> (<b>CI</b>) - это практика, реализуемая с помощью рассмотренных нами технологий, при которой разработчики как можно чаще фиксируют свои изменения в центральном (удаленном) репозитории. Центральный репозиторий обнаруживает поступившие изменения и запускает автоматические тесты на код. Затем он компилирует/сборку конечного продукта. Это происходит непрерывно, в отличие от практики слияния и компиляции в определенную дату перед запуском.</p> <p> <p><b>Непрерывная работа</b>.
			<p><b>Continuous Delivery</b> (<b>CD</b>) строится на основе CI и предполагает развертывание выпущенного продукта в конечном месте. Вы можете настроить этот процесс на создание предварительных версий программного обеспечения или веб-приложений (например, бета-версий, ночных сборок и т.д.), а также запрограммировать дату выпуска для конечного размещения и доставки клиентам (иногда эта последняя часть может включать в себя отдельный процесс и называется <b>Continuous Deployment</b>). Оба упомянутых ранее сервиса (GitHub и GitLab) предлагают подобные услуги.</p>
			<p>Используя эти концепции, можно организовать целый автоматизированный рабочий процесс от рабочего стола до Интернета, где простой Git-коммит и push на сервер запускают тестирование приложения и его публикацию в Интернете. Способ реализации этого рабочего процесса зависит от инструмента, используемого для реализации CI и CD.</p>
			<h1>Обзор</h1>
			<p>В этой главе мы рассмотрели очень важные понятия, касающиеся заботы о качестве нашего кода. Мы узнали, как устанавливать официальные инструменты для выполнения автоматизированных тестов в нашем коде и компонентах, а также как отслеживать изменения и управлять ими в исходном коде.  Хотя приведенные здесь примеры и информация носят ознакомительный характер, они достаточно подробны для того, чтобы применять их в собственных проектах и постоянно расширять свои познавательные навыки. Концепции CI и CD, а также сервисы, предоставляемые онлайновыми репозиториями, также дают прочную основу для их освоения, поскольку все они основаны на функциональности, предоставляемой Git'ом. Все эти инструменты имеют профессиональную ценность для разработчика и необходимы в современной индустрии.</p>
			<h1>Вопросы к обзору</h1>
			<ul>
				<li>Почему важно автоматизированное тестирование? Устраняет ли оно необходимость проведения ручного тестирования?
				<li>Что необходимо для тестирования наших однофайловых компонентов в Vue? </li>
				<li>Что такое контроль исходных текстов, и почему он необходим?</li>
				<li>Что такое Git, и чем он отличается от GitHub/GitLab? </li>
				<li>Когда вы изменяете файл в ветке, изменяется ли он во всех остальных ветках? Почему это происходит или не происходит?</li>
				<li>Одинаковы ли команды для управления Git'ом на всех платформах? </li>
				<li>Что означают термины CI и CD, и какую ценность они добавляют в рабочий процесс?</li>
			</ul>