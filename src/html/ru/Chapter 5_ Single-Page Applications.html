			<h1>Одностраничные приложения</h1>
			<p>В этой главе мы продолжаем совершенствовать свои навыки работы с Vue 3, знакомясь с <b>одностраничными приложениями</b> (<b>SPA</b>). Мы узнаем, что отличает их от обычных сайтов, и рассмотрим их ключевые характеристики. Чтобы применить полученные знания на практике, мы создадим новую версию приложения To-Do с использованием маршрутизатора Vue Router и иной схемы взаимодействия, чем в предыдущих главах. Мы также изучим методы аутентификации на примерах кода.</p> <p>В конце главы мы рассмотрим методы аутентификации.
			<p>К концу этой главы вы будете знать следующее:</p>
			<ul>
				<li>Как создавать SPA с помощью Vue 3</li>
				<li>Как организовать приложение для использования Vue Router с различными стратегиями маршрутизации</li>
				<li>Как переделать наше приложение To-Do с практическим применением различных паттернов</li>
				<li>Как реализовать различные паттерны аутентификации в SPA</li>.
			</ul>
			<p>Если предыдущая глава была несколько перегружена фундаментальными знаниями, то теперь мы больше сосредоточимся на практических вопросах. В связи с этим вам потребуется доступ к приложениям-примерам, чтобы разобраться с ними.</p>
			<h2>Технические требования</h2>
			<p>Код этой главы можно найти на GitHub по адресу </span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter05"><span class="No-Break">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter05</span></a><span class="No-Break">.</p>
			<p>Посмотрите следующее видео, чтобы увидеть код в действии: </span><a href="https://packt.link/RnAyz"><span class="No-Break">https://packt.link/RnAyz</a></p> <p>.
			<h2>Что такое SPA? </h2>
			<p>Чтобы объяснить, что такое SPA, необходимо сначала объяснить, как мы взаимодействуем с <b>World Wide Web</b> (<b>WWW</b> или <b>W3</b>). Когда мы вводим адрес в веб-браузере, то получаем веб-страницу, отправленную веб-сервером. В самом общем виде веб-сайт представляет собой набор страниц, в основном так называемых "статических страниц". Статические в данном контексте означают, что на сервер отправляются одни и те же файлы без изменений. Это делает сайт очень быстрым и безопасным. Однако чисто статический сайт не обеспечивает большой интерактивности для конечного пользователя. Иногда это называют <b>Web 1.0</b>. Серверные и браузерные сценарии позволили решить это ограничение и породили <b>многостраничные приложения</b> (<b>МСП</b>). Теперь страницы могли быть как статическими, так и динамически генерируемыми на сервере, который, в свою очередь, также мог получать вызовы новых страниц с дополнительными данными, обрабатывать их и возвращать в ответ новую страницу. Эти новые страницы, "генерируемые на лету", получили название <b>динамических</b> и сделали возможным появление приложений. Благодаря этим технологиям стало возможным распространение блогов, сервисов и предприятий.</p> <p> С появлением динамических страниц стало возможным появление приложений.
			<p>С появлением таких ключевых технологий, как асинхронные коммуникации (<b>AJAX</b>), более мощный JavaScript, методологии локального хранения данных, увеличение скорости сети и вычислительной мощности, мы пришли к тому, что называется <b>Web 2.0</b>. Теперь можно было загрузить в браузер один файл и с помощью JavaScript взять под контроль весь интерфейс и интерактивность, создавая насыщенные интерактивные приложения без генерации новых страниц на сервере. SPA обращается к серверу только для загрузки битов данных, пользовательского интерфейса и т.д. по мере необходимости. Появилась возможность переносить на веб-технологии то, что было традиционными "настольными" приложениями, такими как текстовые редакторы, электронные таблицы, почтовые клиенты, пакеты графического дизайна и т.д. Хорошими примерами SPA являются <i>Office 365</i>, <i>Google Docs</i>, <i>Photoshop online</i>, <i>Telegram</i>, <i>Discord</i>, <i>Netflix</i>, <i>YouTube</i> и т.д. Важно отметить, что появление SPA не отменяет использование MPA и не делает их устаревшими - каждый из них полезен в определенных контекстах. Большинство блогов и новостных сайтов сегодня, по сути, являются ОМР и по-прежнему составляют значительную часть Интернета. Наиболее сложные веб-приложения сегодня включают в себя смесь MPA и SPA, работающих вместе. SPA могут даже устанавливаться как гибридные приложения на настольных и мобильных устройствах. Как это реализовать, мы увидим в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_06.xhtml#_idTextAnchor148"><i>главе 6</i></span></a>, <i>Прогрессивные </i><span class="No-Break"><i>Web-приложения</i></span><span class="No-Break">.</p>.
			<p>С развитием распределенных и децентрализованных вычислений, а также "умных" блокчейнов технология, на основе которой создаются SPA, приобрела еще большую актуальность. Хотя эта новая эра в развитии веб-технологий еще не полностью укоренилась, ее называют <b>Web 3.0</b>. В этой главе мы рассмотрим эту тему более подробно и на примерах.</p> <p>Все приложения, используемые в SPA-системах, не имеют аналогов в мире.
			<p>Все приложения, которые мы сделали до сих пор, относятся к категории SPA, даже если мы еще не использовали весь их потенциал. Vue 3 специально предназначен для создания приложений такого типа и является одной из наиболее актуальных технологий для такого подхода, наряду с <i>React</i>, <i>Angular</i>, <i>Svelte</i> и другими. Но не все так радужно и сахарно. Как и в любой другой технологии, в использовании SPA есть свои компромиссы. В следующей таблице мы перечислим некоторые из них:</p>
			<table id="table001-3" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col>
					<col>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>Преимущества</b></p>
						</td>
						<td class="No-Table-Style">
							<p><b>Недостатки</b></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<ul>
								<li>Более быстрая и эффективная загрузка</li>
								<li>Локальное кэширование для повышения производительности</li>
								<li>Разнообразные пользовательские интерфейсы и интерактивность</li>
								<li>Проще в разработке и тестировании, чем MPA</li>
								<li>Более эффективное использование кода и шаблонов, с меньшим количеством сетевых взаимодействий (по сравнению с перезагрузкой всей страницы)</li> <li>Высокая производительность.
							</ul>
						</td>
						<td class="No-Table-Style">
							<ul>
								<li>Затруднение индексации и обнаружения поисковыми системами</li>.
								<li>Увеличение сложности</li>
								<li>Увеличение времени загрузки и замедление времени появления первых интерактивных элементов</li>
							</ul>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Таблица 5.1 - Преимущества и компромиссы для SPA</p>.
			<p>Как видите, список преимуществ намного важнее, чем недостатков. Использование SPA следует рассматривать в тех случаях, когда приложение требует значительной интерактивности пользователя и обратной связи в реальном времени. Теперь, когда мы лучше представляем себе, что такое SPA, давайте рассмотрим ключевую концепцию, лежащую в основе их функциональности: приложение </span><span class="No-Break"><b>маршрутизатор</b></span><span class="No-Break">.</p>
			<h2>Роутер Vue 3</h2>
			<p>Vue - отличный фреймворк для создания SPA, но без маршрутизатора эта задача вскоре стала бы довольно сложной. Маршрутизатор Vue - это официальный плагин, который берет на себя навигацию по приложению и сопоставляет URL с компонентом. Это дает нам преимущества MPA. С помощью маршрутизатора мы можем сделать следующее:</p>
			<ul>
				<li>Создавать динамические маршруты к компонентам и управлять ими, при необходимости автоматически подбирая параметры к реквизитам</li>.
				<li>Идентифицировать маршруты (адреса и компоненты) по имени и запускать навигацию по коду</li>.
				<li>Динамическая загрузка компонентов при необходимости, что позволяет уменьшить размер пакета</li>.
				<li>Создать естественный и логичный подход к навигации по сайту и разделению кода</li>
				<li>Управлять навигацией с помощью известных событий, до и после того, как навигация произошла</li>
				<li>Создание анимации перехода между страницами таким образом, который невозможен при использовании MPA</li>.
			</ul>
			<p>Реализация маршрутизатора Vue 3 проста и соответствует той же методологии, что и в случае с другими компонентами экосистемы. Давайте возьмем наш проект из <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_04.xhtml#_idTextAnchor102"><i>главы 4</i></span></a>, <i>Композиция пользовательского интерфейса с компонентами</i>, и модифицируем его для использования маршрутизатора <span class="No-Break">Vue.</p>
			<h3>Установка</h3>
			<p>При запуске нового проекта вы могли заметить, что в меню программы установки есть возможность установить маршрутизатор Vue. Если вы не выбрали эту опцию, как мы сделали в нашем примере, то последующая установка достаточно проста. В терминале, в каталоге проекта, просто выполните следующую команду:</p>
			<pre class="console">$ npm install vue-router@4</pre>
			<p>Команда загрузит и установит зависимости, как и для любого другого пакета в каталоге <b>node_modules</b>. Для того чтобы использовать его в нашем приложении, необходимо выполнить следующие действия:</p>
			<ol>
				<li>Создать наши маршруты.</li>
				<li>Связать маршруты с нашими компонентами.</li>
				<li>Включить маршрутизатор в наше приложение.</li>
				<li>Установите наши шаблоны, в которых маршрутизатор будет отображать наши компоненты.</li>
			</ol>
			<p>Как и многие другие компоненты фреймворка, маршрутизатор не указывает, в каких директориях или организациях должны быть размещены ваши маршруты или компоненты. Однако существует соглашение, которое мы будем использовать и которое стало стандартом де-факто в отрасли. В папке <b>/src</b> создайте следующие каталоги:</p>
			<ul>
				<li><b>/router</b> (или <b>/routes</b>): Здесь будут находиться наши JavaScript-файлы с маршрутами для нашего приложения</li>.
				<li><b>/views</b>: В этой папке будут находиться компоненты верхнего уровня, соответствующие навигации приложения (в качестве лучшей практики)</li>.
			</ul>
			<p>После создания этих каталогов мы готовы приступить к модификации нашего приложения для включения навигации по маршруту. Но прежде давайте рассмотрим, чего мы хотим добиться с помощью нашего маршрутизатора.</p>
			<h3>Новое приложение To-Do</h3>
			<p>В нашем новом приложении будут повторно использоваться компоненты для отображения списка дел, но также будет предусмотрена возможность создания нескольких списков или проектов. Мы будем отображать боковую панель со всеми нашими проектами, и при их выборе список будет обновляться11. Эти проекты также будут сохраняться в браузере, чтобы мы могли вернуться к ним позже с помощью <b>localStorage</b>. В результате мы получим очень простую навигацию с двумя страницами верхнего уровня (компонентами):</p>
			<ul>
				<li>Посадочная страница, на которой мы можем создавать новые проекты</li>
				<li>Страница проекта, на которой мы можем работать со списком дел</li>.
			</ul>
			<p>Следуя этим простым предпосылкам, наше приложение в готовом виде будет выглядеть следующим образом:</p>
			<div>
				<div>
					<img src="images/Figure_5.01_B18602.jpg" alt="Рисунок 5.1 - Наша целевая страница" width="991" height="390">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 5.1 - Наша посадочная страница</p>
			<p>Как видно на <i>Рисунке 5</i></span><i>.1</i>, целевая страница является также местом, где мы можем создавать новые проекты. Для сбора пользовательского ввода мы, как и раньше, используем модальные диалоги. На боковой панели отображается ссылка на страницу <b>Home</b> (целевая страница) и список с названиями различных проектов, которые мы создали. При щелчке на каждом из них маршрут в браузере (URL) будет обновляться, как и страница, и мы увидим нечто <span class="No-Break">подобное этому:</p>
			<div>
				<div>
					<img src="images/Figure_5.02_B18602.jpg" alt="Рисунок 5.2 - Страница проекта To-Do" width="1015" height="448">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 5.2 - Страница проекта To-Do</p>
			<p>Последний скриншот вы можете узнать, поскольку именно его отображает наш компонент <b>ToDoProject.vue</b>. Собственно говоря, для достижения этого результата потребуется совсем немного модификаций. А пока давайте начнем с маршрутов.</p>
			<h3>Определение маршрутов и объект Router</h3>
			<p>Чтобы создать маршруты для нашего проекта, необходимо сначала определить их в собственном модуле. В каталоге <b>/router</b> создайте файл <b>index.js</b> со следующим содержимым:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/router/index.js</p>
			<pre class="source-code">import {<b>createRouter</b>,<b>createWebHashHistory</b>} from 'vue-router'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//1</b>
import Landing from "../views/Landing.vue"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//2</b>
const <b>маршруты</b>= [
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{path: "/",name: "landing",component: Посадка},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{path: "/project/:id",name: "project",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;компонент: <b>() =&gt;</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import(</b>"../views/ToDoProject.vue"<b>)</b>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//3</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;props: true
}],
<b>router </b>= createRouter(<b>{</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//4</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;history: createWebHashHistory(),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>//5</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;маршруты,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scrollBehavior(to, from, savedPosition){return{top:0}}
<b>}</b>)
export default router;</pre>
			<p>Начнем наш файл с импорта двух конструкторов из пакета <b>vue-router</b>, в строке </span><span class="No-Break"><b>//1</b></span><span class="No-Break">:</p>
			<ul>
				<li><b>createRouter</b>, который создаст объект маршрутизатора, который мы можем внедрить в наше приложение в качестве плагина</li>.
				<li><b>createWebHashHistory</b>, который является конструктором, который мы передадим нашему объекту маршрутизатора, и указывает, как он будет управлять перезаписью URL в браузере</li>.
			</ul>
			<p><b>Web hash history</b> будет отображать <b>#</b> (знак числа) в URL и указывать, что вся навигация указывает на один файл. Все навигационные и URL-параметры будут следовать этому знаку. Это самый простой метод, не требующий специальной настройки. Однако есть и другие доступные методы: <b>Web history</b> (также известный как <i>HTML5 mode</i> или <i>pretty URLs</i>) и <b>Memory</b>. Web history не использует хэш-нотацию, но требует специальной конфигурации сервера. Как это сделать, мы рассмотрим на примерах в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_10.xhtml#_idTextAnchor224"><i>главе 10</i></span></a>, <i>Развертывание приложения</i>. Режим памяти не изменяет URL и используется в основном для веб-представлений (как в гибридных фреймворках, таких как NW.js, Electron, Tauri, Cordova, Capacitor и т.д.) и <b>серверного рендеринга</b> (<b>SSR</b>). Пока мы остановимся на методе <b>Web hash </b><span class="No-Break"><b>history</b></span><span class="No-Break">.
			<p>В строке <b>//2</b> мы импортируем компонент, используя нотацию static, и определяем массив <b>routes</b> с нашими маршрутами. Каждый маршрут представлен объектом, содержащим как минимум следующие поля:</p>
			<ul>
				<li><b>путь</b>: Строка, представляющая URL, связанный с компонентом</li>.
				<li><b>имя</b>: Строка, которая ведет себя как уникальный идентификатор маршрута и которую мы можем вызывать программно</li>
				<li><b>component</b>: Компонент, который будет отрисовываться</li>.
			</ul>
			<p>Обратите внимание, что в строке <b>//2</b> мы импортируем статический компонент, а в строке <b>//3</b> используем нотацию динамического импорта. Это означает, что первый маршрут (с именем <b>"landing"</b>) будет включен в основной пакет, а второй маршрут (в строке <b>//3</b> с именем <b>"project"</b>) будет загружен только при первой необходимости, из отдельного пакета. Используя маршруты, мы можем создать стратегию, позволяющую улучшить загрузку приложения и уменьшить размер пакета.</p> <p>Подробнее
			<p>И наконец, в строке <b>//4</b> мы создаем наш объект <b>маршрутизатор</b>, используя конструктор и передавая объект options. Обратите внимание на то, что в строке <b>//5</b> мы передаем поле <b>history</b> конструктору для выбранного нами метода <b>history</b>. Мы также передаем наши маршруты (очевидно), а также в качестве примера создаем одну из возможных <i>навигационных защит</i>, чтобы убедиться, что после перехода по каждому маршруту окно прокручивается до самого верха. Без этого мы можем столкнуться со странным побочным эффектом, когда прокрутка не будет меняться между "<i>страницами</i>". Навигационные защитные экраны срабатывают до и после навигационного события. Они могут использоваться во множестве ситуаций, например, для контроля аутентификации или предварительной загрузки данных. Полный список гвардейцев с примерами приведен в официальной документации (</span><a href="https://router.vuejs.org/guide/advanced/navigation-guards.html"><span class="No-Break">https://router.vuejs.org/guide/advanced/navigation-guards.html</span></a><span class="No-Break">).</p> <p>Во втором маршруте мы видим, что гвардейцы срабатывают по событию навигации.
			<p>Во втором маршруте мы также включили в обозначение пути вариант с включением именованного параметра, перед которым ставится точка с запятой (<b>:id</b>). Этот маршрут будет соответствовать всему, что следует за <b>/project/</b>, и присваивать его реактивной переменной, к которой мы можем обращаться программно (как это работает, мы увидим позже). Маршрут также имеет дополнительное поле, <b>props: true</b>. Оно указывает на то, что параметр, названный в маршруте, будет автоматически передан компоненту в качестве реквизита, если компонент определил реквизит с таким же именем. Это станет полезным и очевидным в следующих разделах.</p>
			<p>После того как маршруты и маршрутизатор определены, пришло время импортировать их в файл <b>main.js</b> и присоединить к нашему приложению. Теперь файл будет выглядеть следующим образом:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/main.js</p>
			<pre class="source-code">import { createApp } from 'vue'
import router from "./router"
import App from './App.vue'
import Modals from "./plugins/modals"
import styles from "./assets/styles.css"
createApp(App)<b>.use(router)</b>.use(Modals).mount('#app')</pre>
			<p>Достаточно просто - теперь необходимо создать компоненты, которых сейчас нет, и адаптировать те, которые есть. Прежде чем приступить к работе с кодом, давайте посмотрим, какие новые компоненты маршрутизатор предоставляет нашему приложению.</p>
			<h3>Шаблонные компоненты маршрутизатора</h3>
			<p>Когда мы включаем маршрутизатор в приложение, он инжектирует в глобальную область видимости следующие новые компоненты:</p>
			<ul>
				<li><b>RouterView</b>: Этот компонент предоставляет место, где будут отображаться компоненты маршрута.</li>
				<li><b>RouterLink</b>: Обеспечивает простой способ привязки к маршрутам; с помощью удобных реквизитов и стилей мы можем контролировать внешний вид и конечный элемент рендеринга.</li>
			</ul>
			<p>Вместе с определением маршрутизатора и маршрутов эти два компонента в нашем шаблоне позволяют предложить навигацию и лучше организовать наш код. Прежде чем разбираться с ними, давайте посмотрим, как они работают в нашем приложении. Начнем модифицировать наш компонент <b>App.vue</b>, чтобы превратить его в контейнер макета (стили опущены):</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">App.vue</p>
			<pre class="source-code">&lt;script setup&gt;
&nbsp;&nbsp;&nbsp;&nbsp;import Sidebar from './components/Sidebar/Sidebar.vue';
&lt;/script&gt;
&lt;template&gt;
&lt;div class="app"&gt;
&nbsp;&nbsp;&nbsp;&lt;Sidebar&gt;&lt;/Sidebar&gt;
&nbsp;&nbsp;&nbsp;&lt;main&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;router-view&gt;&lt;/router-view&gt;
&nbsp;&nbsp;&nbsp;&lt;/main&gt;
&lt;/div&gt;
&lt;/template&gt;</pre>
			<p>Как видите, мы включаем новый компонент <b>Sidebar</b>, который будет содержать основную навигацию нашего приложения. Затем мы помещаем единственный компонент <b>&lt;router-view&gt; </b>, в котором наш маршрутизатор будет отображать каждую страницу. Что касается стилей, то за подробностями я обращусь к коду на GitHub. Теперь пришло время создать компонент <b>Sidebar</b> по пути <b>/src/components/Sidebar/Sidebar.vue</b> и скопировать код из репозитория. В этом небольшом файле есть на что посмотреть. Начнем разбираться с шаблона и с того, как мы используем экземпляры <b>RouterLink</b>. Первый из них статичен и указывает на целевую страницу. Вместо того чтобы просто использовать ссылку или тег якоря, мы определяем цель ссылки как объект, в котором напрямую ссылаемся на имя маршрута:</p> <p>
			<pre class="source-code">&lt;RouterLink <b>:to="{name:'landing'}"</b> class="w3-padding" active-class="w3-yellow"&gt;Home&lt;/RouterLink&gt;</pre>.
			<p>По умолчанию при выводе этого компонента он становится тегом якоря, а атрибут <b>href</b> динамически преобразуется в соответствующий маршрут. Если мы изменим определение маршрута и зададим ему другой путь, это никак не повлияет на данный код. Хорошей практикой является обращение к маршрутам по их именам, а не по их URL. В случае, если нам необходимо передать в URL параметры строки запроса, мы можем легко сделать это, передав в качестве атрибута <b>params </b> объект с членами ключ/значение. Вот пример:</p>
			<pre class="source-code">&lt;RouterLink :to="{name:'search',<b>params:{text:'abc' }</b>}" &gt;Search&lt;/RouterLink&gt;</pre>
			<p>Предшествующий атрибут <b>params</b> будет отображен как URI со строкой запроса <b>?text=abc</b>. Как мы уже говорили, если у маршрута активен атрибут <b>props</b> и принимающий компонент определил одноименный prop, то значение будет присвоено автоматически. Именно такая ситуация позволяет нам сформировать список ссылок и передать на страницу нашего проекта идентификатор каждого проекта, что можно увидеть далее в файле:</p>
			<pre class="source-code">&lt;div v-for="p in _projects" :key="p.id"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;RouterLink <b>:to="{name:'project',params:{id:p.id}}"</b>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{p.name}}
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/RouterLink&gt;
&lt;/div&gt;</pre>
			<p>При создании проекта на посадочной странице каждому из них автоматически присваивается уникальный идентификатор, который мы используем в предыдущем коде. Как и в случае с другими реквизитами, мы можем следить за изменениями и реагировать на них, загружая соответствующие пункты To-Do для каждого проекта. Исходя из этого, мы модифицировали файл <b>ToDoProject.vue</b>, чтобы определить реквизит (тип определять не нужно):</p>
			<pre class="source-code">$props=defineProps(["id"])</pre>
			<p>Также мы установили наблюдатель для обнаружения изменений с помощью этих строк в <b>script </b></span><span class="No-Break">разделе:</p>
			<pre class="source-code">import { <b>watch </b>} from "vue"
watch(<b>()=&gt;$props.id</b>, loadProject)</pre>
			<p>Этот watch получает функцию, которая возвращает атрибут <b>prop</b>, а затем запускает функцию <b>loadProject()</b>. На этом этапе вы можете спросить, зачем нам это нужно, ведь каждый URL-адрес отличается. Ответ заключается в том, что Vue и маршрутизатор загружают компонент только в первый раз, когда он нужен. До тех пор, пока он остается в поле зрения, он не перезагружается и только обновляет реактивные свойства. Поскольку наш код <b>настройки скрипта</b> выполняется только при первой загрузке, в момент создания, нам нужен способ обнаружения изменений для выполнения нереактивных операций, таких как загрузка пунктов To-Do для проекта из </span><span class="No-Break"><b>localStorage</b></span><span class="No-Break">.</p> <p> </span>.
			<p>Остальные изменения можно проследить в репозитории. В компонентах, работающих со списком дел, меняется очень мало, в этом и заключается смысл инкапсуляции. Даже модификация <b>ToDoProject.vue</b> невелика. Однако есть одно дизайнерское решение, на которое следует обратить внимание: использование модели <i>pub/sub</i> для синхронизации меню боковой панели.</p>
			<p>Мы создали синглтон с шиной событий (<b>eventBus</b>). Когда мы создаем новый проект или удаляем его, мы вызываем событие обновления с помощью следующей строки:</p> <p>
			<pre class="source-code">eventBus.emit("<b>#UpdateProjects</b>")</pre>.
			<p>Мы регистрируем прослушивание событий в тех компонентах, которым это необходимо, во время события <i>монтирования</i> жизненного цикла компонента, и снимаем его с регистрации перед <i>размонтированием</i>. В нашем случае он нужен только в компоненте <b>Sidebar</b>, но при необходимости его можно разместить в любом месте нашего приложения:</p>
			<pre class="source-code">onMounted(()=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eventBus.on("<b>#UpdateProjects"</b>, updateProjects)
})
onBeforeUnmount(()=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;eventBus.off("<b>#UpdateProjects</b>", updateProjects)
})</pre>
			<p>Имя события тривиально и не подчиняется никаким соглашениям. В этой книге мы добавляем к нему цифровой знак, как личное предпочтение.
			<p>В предыдущих реализациях, а также в компоненте <b>ToDoProject.vue</b>, мы использовали родителя в качестве канала для обмена информацией между компонентами-братьями, о чем мы говорили ранее. Здесь мы используем другую модель, паттерн <i>pub/sub</i>, чтобы не загрязнять компонент <b>App.vue</b> подобной задачей. В <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_07.xhtml#_idTextAnchor173"><i>главе 7</i></span></a>, <i>Управление потоком данных</i>, мы рассмотрим другие подходы к централизованному управлению состоянием. Теперь рассмотрим более подробные примеры и детали использования маршрутизатора в более <span class="No-Break">продвинутых сценариях.</p> <h3>Вложенные маршруты</h3>.
			<h3>Вложенные маршруты, именованные представления и программная навигация</h3>.
			<p>До сих пор мы создавали статические и динамические маршруты, даже с некоторыми параметрами в адресе. Но маршрутизатор может делать даже больше. Используя именованные маршруты, мы можем также создавать "подмаршруты" и именованные "вьюшки" для создания более глубоких навигационных деревьев и сложных макетов.</p> <p> Для начала давайте разберемся с тем, что такое маршрутизация.
			<p>Начнем с примера. Предположим, у нас есть трехуровневая структура данных, и мы хотим реактивно представить ее пользователю таким образом, чтобы он мог выбрать один уровень, а затем "спуститься" к деталям. Мы также хотим, чтобы это отражалось в URL-адресе, чтобы можно было поделиться или сослаться на полный текст дела. В данном случае уровнями будут страна, штат и город. В этом случае пользовательский интерфейс будет выглядеть следующим образом:</p>
			<div>
				<div>
					<img src="images/Figure_5.03_B18602.jpg" alt="Рисунок 5.3 - Выборка с использованием нескольких именованных представлений и подмаршрутов" width="908" height="367">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 5.3 - Выборка с использованием нескольких именованных представлений и подмаршрутов</p>
			<p>Как видно из скриншота, при выборе пользователем страны заполняется список штатов и обновляется URL. При выборе штата обновляется список городов... и, наконец, при выборе города информация появляется в последнем столбце. Возможно, вы уже встречали такой способ навигации. Существует множество способов его реализации, одни из которых более эффективны, чем другие. Мы хотим реализовать это в качестве учебного упражнения, поэтому начнем с определения маршрутов. Вот фрагмент массива определения наших маршрутов:</p>
			<pre class="source-code">{
path: "/directory", name: "directory",
component: () =&gt; import("../views/Directory.vue"),
children:[
{ path: "<b>:country</b>", name: "states", props: true,
&nbsp;&nbsp;component: ()=&gt;import("../views/State.vue"),
&nbsp;&nbsp;<b>children:[</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ path:"<b>:state</b>", name: "cities", props: true,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;компонент: ()=&gt;import("../views/City.vue")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<b>&nbsp;]</b>
} <b>]</b> }</pre>
			<h4>Определение вложенных маршрутов</h4>
			<p>На первый взгляд, мало что изменилось, кроме включения в маршрут нового атрибута: <b>children[]</b>. Этот атрибут получает массив маршрутов, которые, в свою очередь, могут иметь другие дочерние маршруты, как мы видим в предыдущем фрагменте кода. Дочерние маршруты будут отображаться в компоненте <b>RouteView</b> своих родителей, а их пути будут конкатенированы с путями родителей, если только они не начинаются с корня (с обратной косой черты).</p> <p>Для навигации по маршруту, который будет отображаться в родительском компоненте <b>RouteView</b>, необходимо использовать атрибут <b>RouteView</b>.
			<p>Для перехода к каждому маршруту мы можем использовать любой из методов, распознаваемых маршрутизатором. Однако хорошей практикой является использование их имен и передача любого параметра или строки запроса через объект, и пусть маршрутизатор разрешает URL. В качестве примера посмотрим, как в компоненте <b>Directory.vue</b> мы используем элемент <b>RouterLink</b></span><span class="No-Break">:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/src/views/Directory.vue component, lines 13-18</p>
			<pre class="source-code">&lt;div v-for="c in countries" :key="c.code"&gt;
&lt;RouterLink
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:to="<b>{name:'states', params:{country:c.code}}</b>"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;active-class="selected"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{c.name}}
&lt;/RouterLink&gt;
&lt;/div&gt;</pre>
			<p>Мы включили наш компонент <b>RouterLink</b> внутрь цикла, чтобы создать столько ссылок, сколько необходимо на основе наших данных. Целью ссылки является объект, в который мы передаем имя маршрута (<b>states</b>), а также передаем параметры, соответствующие определению маршрута и реквизита компонента. Обратите внимание, что путь компонента определен как параметр (он начинается с двоеточия - <b>:country</b>), и он также соответствует props-определению объекта в <b>State.vue</b>. Именно это соответствие позволяет маршрутизатору автоматически передавать нам данные.</p> <p> При осмотре мы увидим, что в объекте <b>State.vue</b> есть и другие реквизиты.
			<p>Проанализировав код, можно заметить, что в самом маленьком дочернем компоненте, файле <b>City.vue</b>, мы определяем в реквизите и страну, и государство. Однако в определении маршрута появляется только один параметр - state (<b>:state</b>). Тем не менее, запустив пример, можно заметить, что этот реквизит также заполнен. Это происходит потому, что дочерние компоненты наследуют вместе с URL-путем все параметры, определенные в маршруте родительского компонента. В данном случае наш компонент также получает параметр <b>:country</b>, который был передан родителю, даже если он не отображается в его конкретном маршруте.</p> <p>При запуске примера компонент получает параметр <b>:country</b>.
			<p>Запустив приложение, вы увидите нечто похожее на этот снимок экрана:</p>
			<div>
				<div>
					<img src="images/Figure_5.04_B18602.jpg" alt="Рисунок 5.4 - Пример вложенных маршрутов, с выделениями" width="855" height="486">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 5.4 - Пример вложенных маршрутов, с выделениями</p>.
			<p>Для простоты из статических файлов были включены только две страны. В реальном проекте эти данные будут получены из базы данных.</p> <p> До сих пор мы использовали в качестве примера вложенные маршруты.
			<p> До сих пор мы использовали компоненты <b>RouteView</b> "по умолчанию", но маршрутизатор Vue позволяет включать несколько представлений в один компонент, присваивая им разные имена. Здесь мы рассмотрим только обозначения, поскольку реализация тривиальна. Рассмотрим компонент со следующим шаблоном:</p>
			<pre class="source-code">&lt;div&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;RouterView <b>name="header"</b>&gt;&lt;/RouterView&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;RouterView <b>name="sidebar"</b>&gt;&lt;/RouterView&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;RouterView&gt;&lt;/RouterView&gt;
&lt;/div&gt;</pre>
			<p>В предыдущем коде мы присваиваем нашим маршрутам идентификацию с помощью атрибута <b>name</b>. У нас также есть представление без имени, в этом случае оно считается представлением "по умолчанию", или с именем <b>default</b>. Для использования этой новой схемы немного меняется определение маршрутов. Теперь в каждом определении у нас нет атрибута <b>component</b>, а вместо него есть атрибут <b>components</b> (во множественном числе), который ожидает объект. Имя каждого поля в объекте должно совпадать с именами, заданными нашим компонентам <b>RouterView</b>, и быть равным объекту. Для предыдущего фрагмента кода эквивалентное определение маршрута будет выглядеть следующим образом:</p>
			<pre class="source-code">{ path:"/layout", name: "main",
&nbsp;&nbsp;components:<b>{</b>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: ()=&gt;import('...'),</b>.
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header: ()=&gt;import('...'),</b> <b>.
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sidebar: ()=&gt;import('...')</b>.
<b>}</b>}</pre>.
			<p>Используя этот тип определения, мы можем создавать сложные макеты, поскольку можем также определить подмаршруты, которые будут использовать, например, заголовок и боковую панель из родительского блока и будут отображаться только в представлении по умолчанию. У нас есть впечатляющее количество возможностей для создания динамических пользовательских интерфейсов.</p> <p>
			<p>Одна из важных тем, которую мы должны затронуть, прежде чем перейти к следующему разделу, - это программная навигация. До сих пор мы использовали новые компоненты, предоставляемые маршрутизатором, но мы также можем запускать навигацию непосредственно из нашего JavaScript, не полагаясь на то, что пользователь вызовет событие. Для этого Vue Router предоставляет нам два удобных конструктора, которые можно использовать в сценариях наших компонентов: <b>useRoute</b> и <b>useRouter</b>. Мы импортируем эти конструкторы в наши компоненты с помощью следующей строки:</p>
			<pre class="source-code">import {useRoute, useRouter} from "vue-router"
const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$route=useRoute(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$router=useRouter()</pre>
			<p>Как вы понимаете, <b>$route</b> предоставляет нам информацию о текущем маршруте, а <b>$router</b> позволяет изменять и запускать навигационные события.</p>
			<p>Объект <b>$router</b> предоставляет несколько методов, наиболее часто используемые из которых сведены в данную таблицу:</p>
			<table id="table002" class="No-Table-Style">
				<colgroup>
					<col>
					<col>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>Метод</b></p>
						</td>
						<td class="No-Table-Style">
							<p><b>Описание</b></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>.</b><b>push()</b></p>
						</td>
						<td class="No-Table-Style">
							<p>Самый важный метод. Он проталкивает новый URL в веб-историю и осуществляет переход к соответствующему компоненту. Это программный эквивалент использования <b>RouterLink</b>. Он принимает либо строку с URL для перехода, либо объект с необязательными атрибутами. Ниже приведены примеры для каждого принимаемого параметра:</p>
							<pre class="source-code">// Переход к URL-адресу
$router.push(<b>"/my/route"</b>)
// Переход к URL с использованием объекта
$router.push(<b>{path: "/my/route"}</b>)
// Переход к маршруту с параметрами
$router.push({
&nbsp;&nbsp;&nbsp;<b>имя: "route-name",</b>
<b>&nbsp;&nbsp; params:{key:value}</b>
})
// Переход к маршруту со строками запроса
$router.push({
&nbsp;&nbsp;&nbsp;<b>имя: "route-name",</b>
<b>&nbsp;&nbsp; query:{key:value}</b>
})</pre>
							<p>Конечно, можно создавать сложные маршруты, передавая параметры и строки запросов. Важно помнить, что <b>.push </b> приведет к обновлению истории навигации в браузере.</p> <p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>.</b><b>replace()</b></p>.
						</td>
						<td class="No-Table-Style">
							<p>Заменяет текущий компонент навигации, не изменяя URL.
Принимает те же параметры, что и </span><span class="No-Break"><b>.push</b></span><span class="No-Break">.</p>.
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>.</b><b>go()</b></p>
						</td>
						<td class="No-Table-Style">
							<p>Этот метод получает в качестве параметра целое число и запускает навигацию по истории браузера. Положительные числа ведут вперед, а отрицательные - назад по истории навигации. Чаще всего он используется для реализации ссылки "назад" в приложении. Вот несколько примеров:</p>
							<pre class="source-code">// Переход на одну запись назад
$router.go(-1)
// Переход вперед на одну запись
$router.go(1)</pre>
						</td>
					</tr>
				</tbody>
			</table>
			<p>Как уже говорилось, это наиболее часто используемые методы, которые необходимо иметь в наличии. Могу сказать, что их использование позволяет решить подавляющее большинство регулярных задач. Полный список доступных методов можно найти в официальной документации, они позволяют справиться и с возникающими крайними случаями. Рекомендую ознакомиться с ними, хотя бы для того, чтобы знать о них, по адресу <a href="https://router.vuejs.org/api/interfaces/Router.html">https://router.vuejs.org/api/interfaces/Router.html</a>#properties. К таким случаям можно отнести: динамическое добавление и удаление маршрутов (<b>.addRoute()</b> и <b>.removeRoute()</b>), получение зарегистрированных маршрутов (<b>.getRoutes()</b>), проверка наличия маршрута перед переходом к нему (<b>.hasRoute()</b>) и т.д. Мы не будем их использовать, поэтому подробно рассматривать их здесь нецелесообразно.</p> <p> Напротив, в <b>Маршруты</b> мы не будем использовать.
			<p>Напротив, объект <b>$route</b> предоставляет нам информацию о текущем пути (URL), по которому происходит рендеринг нашего компонента. Как и в предыдущем примере, здесь приведен список наиболее часто используемых атрибутов и их назначение:</p>
			<table id="table003" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col>
					<col>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>Атрибуты</b></p>
						</td>
						<td class="No-Table-Style">
							<p><b>Описание</b></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>.</b><b>имя</b></p>.
						</td>
						<td class="No-Table-Style">
							<p>Возвращает текущее имя маршрута.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>.</b><b>params</b></p>
						</td>
						<td class="No-Table-Style">
							<p>Возвращает объект с параметрами, указанными в пути (URL). Если они были сопоставлены с реквизитами, то значения могут пересекаться.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>.</b><b>query</b></p>
						</td>
						<td class="No-Table-Style">
							<p>Возвращает объект с декодированной строкой запроса, привязанной к текущему пути.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>.</b><b>hash</b></p>
						</td>
						<td class="No-Table-Style">
							<p>Если таковые имеются, то возвращается путь в URL, следующий за знаком хэша (</span><span class="No-Break"><b>#</b></span><span class="No-Break">).</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>.</b><b>fullPath</b></p>
						</td>
						<td class="No-Table-Style">
							<p>Возвращает строку с полным путем маршрута.</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>В примерах этой книги мы неоднократно будем использовать <b>.name()</b>, <b>.params()</b> и <b>.query()</b>, поскольку они, как правило, являются наиболее часто используемыми. Полный список методов и свойств можно найти в официальной документации.</p>
			<h6>Важные различия в обозначениях</h6>
			<p class="callout">Мы использовали конструкторы <b>useRoute</b> и <b>useRouter</b> в Composition API с нотацией <b>script setup</b>. В API Options нет необходимости инициализировать эти объекты. Оба они доступны автоматически через <b>this.$route</b> и <b>this.$router</b>. Также объекты <b>$route</b> и <b>$router</b> автоматически доступны в шаблоне при использовании Composition API.</p> <p>Полный пример кода.
			<p>Полный пример кода можно найти в репозитории GitHub, в разделе <b>Глава 5</b></span><b>/Вложенные маршруты</b>, по этому адресу <span class="No-Break">URL: </span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/chapter05"><span class="No-Break">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/chapter05</span></a><span class="No-Break">.</p>
			<p>Теперь, когда мы знаем, как работать с маршрутами, параметрами и строками запросов, пришло время рассмотреть некоторые общие шаблоны аутентификации в SPA, поскольку для многих из них необходимы различные пути (URL).</p>
			<h2>Исследование шаблонов аутентификации</h2>
			<p>Мощность SPA становится очевидной, когда за ними стоит сервер, предоставляющий дополнительные сервисы. Одним из таких сервисов является аутентификация. В большинстве приложений возникает необходимость идентификации пользователей и предоставления дополнительных услуг на основе их прав, статуса, конфиденциальности, группы или любой другой категории, относящейся к контексту приложения. Ярким примером этого являются приложения веб-почты, такие как <i>Outlook</i> или </span><span class="No-Break"><i>Gmail</i></span><span class="No-Break">.</p>
			<p>Современные веб-стандарты предоставляют нам несколько возможностей для осуществления асинхронного взаимодействия с сервером. Их часто называют <b>AJAX</b> (<i>AJAX расшифровывается как Asynchronous JavaScript and XML</i>). В самом базовом виде для таких сетевых взаимодействий мы могли бы использовать объект <b>XMLHttpRequest</b>, но новые спецификации предоставляют нам прямую функцию <b>fetch()</b>, которая является более удобной и стандартной для браузеров. Хотя эти методы вполне допустимы, для других целей, кроме простых нужд, лучше использовать библиотеку, предоставляющую более широкие функциональные возможности, построенные поверх этих технологий - например, такую, которая предоставляет <b>API</b> для соответствия методам <b>HTTP </b>-запросов (<b>GET</b>, <b>POST</b>, <b>PUT</b>, <b>OPTIONS</b> и <b>DELETE</b>) для удобного использования <b>RESTful API</b> (где <b>REST</b> означает <b>Representational State Transfer</b>, тип архитектуры, используемый в сетевых коммуникациях). Подробнее об этом мы поговорим в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_08.xhtml#_idTextAnchor186"><i>главе 8</i></span></a>, <i>Multithreading with Web Workers</i>. Пока же просто имейте в виду, что лучшим вариантом будет библиотека для обработки сетевых асинхронных взаимодействий. В нашем случае мы будем использовать замечательную библиотеку <b>Axios</b> (<a href="https://axios-http.com/">https://axios-http.com/</a>), которую можно установить в свое приложение с помощью следующей команды <span class="No-Break">:</p>
			<pre class="source-code">$ npm install axios</pre>
			<p> Затем в своем сервисе или компоненте вы можете импортировать и использовать библиотеку с помощью следующего кода:</p>
			<pre class="source-code">import axios from "axios"</pre>.
			<p>Библиотека предоставляет методы, соответствующие каждому HTTP-запросу (<b>.get()</b>, <b>.post()</b>, <b>.put()</b> и т.д.), каждый из которых возвращает обещание, разрешающееся в результат запроса или отклоняющее его в случае ошибки.</p>
			<p>После этого мы готовы рассмотреть некоторые общие шаблоны для аутентификации пользователей в наших приложениях.</p>
			<h3>Простая аутентификация по имени пользователя и паролю</h3>
			<p>Это самый простой подход к аутентификации пользователей, при котором проверка учетных данных выполняется нашей реализацией на сервере. В этом случае серверный бэкенд предоставляет API для проверки набора учетных данных, собранных нашим SPA. Традиционно учетные данные хранятся на сервере, в базе данных, а обмен данными будет осуществляться поверх <b>Secure Sockets Layer</b> (<b>SSL</b>) или шифрованного обмена, что одно и то же. Рассмотрим процесс работы графически:</p>
			<div>
				<div>
					<img src="images/Figure_5.05_B18602.jpg" alt="Рисунок 5.5 - Простая аутентификация по имени пользователя и паролю" width="566" height="235">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 5.5 - Простая аутентификация по имени пользователя и паролю</p>.
			<p>В этом рабочем процессе происходит следующее:</p>
			<ol>
				<li> SPA собирает значения имени пользователя и пароля и передает их в определенную конечную точку нашего сервера для аутентификации.</li>
				<li>Сервер использует информацию, хранящуюся в базе данных, для проверки имени пользователя и пароля.</li>
				<li>Результат операции возвращается клиенту SPA в ответ на его первоначальный запрос (</span><span class="No-Break"><i>1</i></span><span class="No-Break">).</li>
			</ol>
			<p>Хотя на рисунке 5</i></span><i>.5</i> показано количество шагов, следует учитывать, что все это делается всего за один сетевой вызов и его ответ. Разработка кода проверки на сервере выходит за рамки данной книги, но код внутри нашего сервиса или компонента Vue 3 будет выглядеть примерно так <span class="No-Break">:</p>.
			<pre class="source-code">import axios from "axios"
import {ref} from "vue"
const _username=ref(""), _password=ref("")
function doSignIn(){
axios.post(<b>"https://my_server_API_URL",</b>
&nbsp;&nbsp;&nbsp;&nbsp;<b>{username:_username.value,password:_password.value})</b>
&nbsp;&nbsp;.then(response=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(<b>response.status)</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(<b>response.data</b>)
&nbsp;&nbsp;}).catch(err=&gt;{...})
}</pre>
			<p>Как видите, реализация достаточно проста и зависит от нашей собственной логики и дизайна API сервера. Важно помнить, что необходимо проверять статус ответа (все, что находится между <b>200</b> и <b>299</b>, является успехом) и данные, отправленные сервером, чтобы действовать соответствующим образом. Все коммуникации и преобразование данных за нас выполняет Axios (при условии, что наш API принимает и обрабатывает данные в формате JSON).</p> <p> В случае успешного ответа на запрос, в случае успешного ответа на запрос, Axios обрабатывает данные в формате JSON.
			<p>В случае успеха мы должны сохранить результат в состоянии нашего приложения и соответственно разрешить доступ пользователю, в основном разблокировав навигацию по частным или ограниченным маршрутам. Такая защита может быть реализована множеством различных способов, наиболее распространенными из которых являются использование навигационных защит, создание динамических маршрутов и т.д.</p> <p>Этот способ может быть использован в качестве основного.
			<p>Этот способ вполне допустим и широко применяется в большинстве приложений. Однако он имеет ряд недостатков:</p> <p>
			<ul>
				<li>Мы отвечаем за ведение базы данных с именами пользователей и паролями (пожалуйста, в зашифрованном виде!) и реализацию логики проверки</li>.
				<li>Мы несем юридическую ответственность за обработку данных пользователей в соответствии с местным законодательством</li>
				<li>Мы отвечаем за всю безопасность системы, от конца до конца</li>
				<li>Пользователь должен помнить или нести ответственность за свои учетные данные</li>
				<li>Мы должны предусмотреть способы обработки нестандартных ситуаций, а также проблем пользователей и поиска учетных данных</li>.
			</ul>
			<p>Эти недостатки ни в коем случае не являются сдерживающим фактором, но являются важными моментами, которые следует иметь в виду, если мы пойдем этим путем. Так или иначе, большинство приложений должны иметь способ аутентификации пользователей, который зависит от их собственной логики и реализации, поскольку не все наши пользователи (в зависимости от контекста) будут готовы использовать другую форму аутентификации, как мы увидим далее.</p> <p>
			<h3>OpenID и сторонняя аутентификация</h3>
			<p> Помимо вопросов безопасности, основной проблемой при аутентификации является то, как легко эти учетные данные могут быть утеряны или неправильно использованы конечным пользователем. Это случается с каждым из нас. Чем больше сервисов мы используем в Интернете, тем большее количество учетных данных пользователю необходимо "помнить". Существует множество различных методов решения этой проблемы, позволяющих снизить нагрузку на пользователя, связанную с запоминанием всех этих имен и паролей. Одним из таких стандартов является протокол <b>OpenID</b> (</span><a href="https://openid.net/"><span class="No-Break">https://openid.net/</span></a><span class="No-Break">)</p>.
			<p>Протокол OpenID обеспечивает аутентификацию пользователей без необходимости обмена учетными данными (именами пользователей и паролями) между сайтами. Он основан на работе протокола <b>OAuth 2.0</b>, который используется для безопасного обмена информацией и ресурсами без необходимости использования паролей. Это достигается путем обмена токенами между различными участниками процесса. Стандартом для таких коммуникаций является использование <b>JSON Web Tokens</b> (<b>JWTs</b>). В этом абзаце можно многое раскрыть, поэтому давайте рассмотрим каждый из этих терминов немного подробнее, чтобы лучше понять, как работает этот протокол.</p> <p> JWT - это токен, который используется для обмена данными между различными участниками.
			<p>JWT - это строка, содержащая три секции, разделенные точкой (<b>.</b>) и закодированные в Base64. Затем каждая секция кодирует JSON-объект со следующей информацией:</p> <p>
			<ul>
				<li><b>Header</b>: содержит криптографическую информацию, используемую для кодирования токена, такую как алгоритм, тип токена (обычно <b>JWT</b>), а в некоторых случаях даже тип данных, представленных в полезной нагрузке.</li>
				<li><b>Платежная нагрузка</b>: этот объект содержит информацию, которую мы хотим (должны) передать, и в основном имеет "свободный формат", то есть может содержать любую пару <b>ключ:значение</b> по мере необходимости. Однако есть несколько четко определенных полей, которые также могут быть использованы, например "<b>iat</b>" (<b>Issued At Time</b>), в котором содержится временная метка создания токена. Самое главное, этот объект должен содержать уникальный идентификатор пользователя (поле "<b>sub</b>", для субъекта).</li>
				<li><b>Подпись</b>: Подпись представляет собой строку, образованную путем конкатенации зашифрованных строковых представлений заголовка и полезной нагрузки, выраженных в Base64. Для шифрования используется секретный ключ (пароль), известный только аутентифицирующему серверу и серверу сайта.</li>
			</ul>
			<p>Получив токен, сайт в рабочем процессе декодирует и проверяет его с помощью секретного ключа, используя тот же метод, что и эмитент. Если подписи не совпадают, то считается, что токен испорчен или скомпрометирован, и он отклоняется. JWT может быть перехвачен и расшифрован третьей стороной, поэтому данный метод является надежной защитой от несанкционированного доступа. Рассмотрим пример создания токена:</p>
			<ul>
				<li><b>Заголовок</b>: <b>{"alg": "HS256", "typ": "JWT"}</b>. Здесь мы используем алгоритм <b>HS256 </b> и объявляем используемый тип как </span><span class="No-Break"><b>JWT</b></span><span class="No-Break">.</li>
				<li><b>Payload</b>: <b>{"sub":"1234567890","name":"Pablo </b><b>D. Garaguso", "iat":</b><strong class="source-inline">
</strong><b>1516239022}</b></span><span class="No-Break">.</li>
				<li><b>Секретный ключ шифрования</b>: <b>секретный ключ</b></span><span class="No-Break">.</li>
			</ul>
			<p>Поле подписи создается по такой формуле (при условии, что у нас есть функция, шифрующая текст по алгоритму HS256):</p>
			<p><b>HMACSHA256(base64UrlEncode(header) + "." + </b><b>base64UrlEncode</b><strong class="source-inline">
(</strong><b>payload), "secret key")</b></p>.
			<p>И наконец, полученные строки в кодировке Base64 снова конкатенируются, в результате чего мы получаем вполне работоспособный токен. Также обратите внимание на то, что каждая секция (заголовок, полезная нагрузка и подпись) разделяется точкой (</span><span class="No-Break"><b>.</b></span><span class="No-Break">):</p>
			<p><b>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwi bmFtZSI6IlBhYmxvIEQuIEdhcmFndXNvIiwiaWF0IjoxNTE2MjM5MDIyfQ.mPr551</b><strong class="source-inline">
</strong><b>xpsCgmIzp8EZuSCoy7t7iQNpp_iGzIR14E_Jo</b></p>.
			<p>Для проверки этого токена можно воспользоваться таким сервисом, как <a href="https://jwt-decoder.com/">https://jwt-decoder.com/</a>. Однако для его проверки необходимо использовать секретный ключ. Проверить его можно на сайте <a href="https://jwt.io/">https://jwt.io</a>, где также можно найти дополнительную информацию об этом стандарте.</p>
			<p>В протоколе OpenID JWT используются для передачи и проверки информации между сторонами, поэтому так важно хорошо понимать эту концепцию. Существует несколько рабочих процессов, поддерживаемых протоколом. Давайте рассмотрим упрощенное представление <b>потока кода авторизации</b> (<a href="https://openid.net/specs/openid-connect-core-1_0.html">https://openid.net/specs/openid-connect-core-1_0.html</a>) протокола со всеми участниками, а затем посмотрим, какие части нам нужно реализовать в наших Vue 3 SPA:</p>
			<div>
				<div>
					<img src="images/Figure_5.06_B18602.jpg" alt="Рисунок 5.6 - Поток кода авторизации OpenID во всей его красе" width="602" height="280">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 5.6 - Поток кода авторизации OpenID во всей его красе</p>.
			<p>Как видите, для реализации этого рабочего процесса нам необходимы три участника: 1) наш SPA, обрабатывающий множество маршрутов, 2) сервер аутентификации <b>service provider</b> (<b>SP</b>) и 3) наш собственный backend-сервер. Можно выполнить аутентификацию и проверку бэкенда в браузере, тогда потребуется только два участника, но это не рекомендуется, так как раскрывается секретный ключ в нашем JavaScript. Однако такая возможность существует для встроенных приложений, например мобильных, где пользователь не имеет свободного доступа к коду страницы (в гибридных приложениях)</p> <p>.
			<p>Для реализации рабочего процесса клиент (наше приложение) должен зарегистрироваться в службе аутентификации. Процесс зависит от каждой сущности, но в результате у нас будет зарегистрировано следующее:</p> <p>
			<ul>
				<li>Идентификационная строка <b>client_id</b>, уникальная для нашего приложения.</li>
				<li>Значение <b>секретного_ключа</b>, которое будет известно только серверу аутентификации и нашему внутреннему приложению. Оно будет использоваться для кодирования и подписи наших токенов.</li>
				<li>Серия <i>конечных точек</i> в сервере аутентификации и в нашем приложении, куда будет перенаправляться пользователь на каждом шаге. Соответствующий обмен токенами будет осуществляться при этих перенаправлениях как часть строки запроса в URL.</li> <li>
			</ul>
			<p> Итак, давайте рассмотрим эти шаги в деталях, а также то, как их реализовать в нашем приложении на Vue 3:</p>
			<table id="table004" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col>
					<col>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><b>Ступень</b></p>
						</td>
						<td class="No-Table-Style">
							<p><b>Описание</b></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>1</p>
						</td>
						<td class="No-Table-Style">
							<p>Пользователю необходимо пройти аутентификацию, поэтому мы перенаправляем его на конечную точку, указанную нам сервером аутентификации. Строка запроса должна содержать следующие (обязательные) поля:</p>
							<ul>
								<li><b>scope</b></span><span class="No-Break">: </span><span class="No-Break"><b>openid</b></li>.
								<li><b>response_type</b></span><span class="No-Break">: </span><span class="No-Break"><b>код</b></li>.
								<li><b>client_id</b>: Идентификатор клиента, выданный сервером аутентификации</li>.
								<li><b>redirect_uri</b>: Тот самый адрес, который мы зарегистрировали на сервере, куда будет перенаправлен пользователь после успешной аутентификации</li>.
								<li><b>state</b>: Любые данные или состояние приложения, которые мы хотим получить в ответ после аутентификации</li>.
							</ul>
							<p>Для подготовки URL перенаправления мы сначала создаем объект с указанными выше полями и значениями, а также используем создателя <b>URLSearchParams</b> для создания строки запроса (см. </span><a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams</span></a><span class="No-Break">):</p>
							<p><b>const </b><b>query_data={scope: "openid", ...},</b></p>
							<p><b>query_string=new URLSearchParams(query_data).toString()</b></p>.
							<p>Следующим шагом мы можем использовать объект location для выполнения перенаправления:</p>
							<p><b>location.assign("https://auth_endpoint" + "?" + </b><b>query_string)</b></p> <p>.
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>2</p>
						</td>
						<td class="No-Table-Style">
							<p>При успешной аутентификации сервер аутентификации перенаправит пользователя на конечную точку, которую мы зарегистрировали в качестве получателя. Передаваемые параметры запроса будут зависеть от результата операции:</p>
							<ul>
								<li>Успешный вход в систему:</span><ul><li><b>code</b>: <b>code_token</b>, который в дальнейшем необходимо обменять на <span class="No-Break">an </span><span class="No-Break"><b>identity_token</b></span><span class="No-Break">.</span></span></li><li><b>state</b>: Любые данные, которые мы отправили на сервер и хотим получить обратно. Мы можем использовать это для перенаправления пользователя внутри нашего приложения, например, <span class="No-Break">.</li></ul></li>
								<li>Неудачный вход в систему:</span><ul><li><b>error</b>: Код ошибки, определенный протоколом (<b>interaction_required</b>, <b> invalid_request_uri</b>, и <span class="No-Break">так далее).</li></ul></li>
							</ul>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"></td>
						<td class="No-Table-Style">
							<p>Переадресация вызовет загрузку нашего приложения, а маршрутизатор - отрисовку указанного нами компонента. В настройках нашего скрипта нам необходимо перехватить переданную нам строку запроса, чтобы затем использовать ее в следующем шаге. Сделать это без использования сторонних библиотек можно с помощью следующего кода:</p>
							<pre class="source-code">import {useRoute} from "vue-router"
const <b>$route=useRoute()</b>
if(<b>$route.query.error</b>){
&nbsp;&nbsp;&nbsp;// Аутентификация не удалась, примите меры
}else{
&nbsp;&nbsp;&nbsp;&nbsp;// Аутентификация прошла успешно, сделайте что-нибудь
&nbsp;&nbsp;&nbsp;sendToServer(<b>$route.query.code)</b>
}</pre>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>3</p>
						</td>
						<td class="No-Table-Style">
							<p>На этом шаге мы просто отправляем полученный код на бэкенд, что означает реализацию функции <b>sendToServer()</b>, о которой говорилось ранее. Поскольку теперь мы имеем дело с нашей собственной реализацией, способ сделать это тривиален. В данном примере мы используем Axios:</p>
							<pre class="source-code">import{axios}from "axios"
function sendToServer(<b>code</b>){
axios
&nbsp;&nbsp;.post("URL нашего сервера", {<b>код</b>})
&nbsp;&nbsp;.then(result=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Устанавливаем токен в наши заголовки
&nbsp;&nbsp;&nbsp;&nbsp;axios.defaults.headers.common={
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>"Authorization": "Bearer " +&nbsp;result.data.identity_token</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}).catch(()=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;// Обработка ошибки
})}</pre>
							<p>В предыдущем примере мы отправили на сервер строку <b>code_token</b> и получили от него в качестве ответа строку <b>identity_token</b>. Затем мы делаем еще один шаг вперед и устанавливаем в заголовках по умолчанию для нашего приложения стандартный заголовок <b>Authorization </b> с маркером <b>Bearer</b>. С этого момента нашему серверу достаточно проверить заголовки и убедиться, что запрашиваемая операция принадлежит действительному пользователю.</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>Выполнение проверки токенов и <i>шагов 4</i> и <i>5</i> выходит за рамки данной книги, поскольку мы рассматриваем приложения на Vue 3. Как видите, та часть, которую должен обрабатывать наш SPA, довольно проста и не содержит большого количества кода (некоторые проверки ошибок для краткости были опущены).</p> <p>Существует достаточно большое количество приложений, в которых используются токены.
			<p>Существует большое количество синдицированных сервисов аутентификации, как бесплатных, так и платных, которые мы можем реализовать в нашем приложении. Наиболее распространенными в наши дни являются значки, перенаправляющие пользователей на их использование, например, для входа в систему с помощью <i>Google</i>, <i>Facebook</i>, <i>Twitter</i>, <i>GitHub</i>, <i>Microsoft</i> и т.д. Существуют также метасервисы, предоставляющие всех вышеперечисленных провайдеров внутри хорошо упакованных библиотек, например <b>Auth0 </b> (<a href="https://auth0.com/">https://auth0.com/</a>, сейчас входит в состав <b>Okta</b>, <a href="https://www.okta.com/">https://www.okta.com/</a>). Когда дело доходит до реализации этого рабочего процесса, мы, конечно, не испытываем недостатка в вариантах.</p>
			<h3>Беспарольная аутентификация или аутентификация по одноразовому паролю (OTP)</h3>.
			<p>Другим решением, позволяющим отказаться от использования учетных данных, является беспарольный доступ. Основная идея заключается в том, чтобы полагаться на безопасность другой системы (электронная почта, мобильные тексты, приложения-аутентификаторы и т.д.) для подтверждения пользователя. В процессе генерируется чувствительный к времени код "одноразового использования" и отправляется пользователю через систему поддержки через внутренний сервис. Внешний сервис (приложение) ожидает ввода права пользователем в определенный промежуток времени. Например, распространенной реализацией является отправка бэкендом на телефон пользователя текстового сообщения с кодом, который необходимо ввести в приложении до истечения времени.</p> <p>Наглядно это можно представить следующим образом.
			<p>Здесь представлено визуальное представление этого рабочего процесса, учитывая, что пользователь был зарегистрирован с помощью электронной почты или номера телефона. Предполагается, что они <i>известны</i>, а значит, их принадлежность проверена:</p> <p>
			<div>
				<div>
					<img src="images/Figure_5.07_B18602.jpg" alt="Рисунок 5.7 - Беспарольная аутентификация на основе электронной почты" width="537" height="331">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 5.7 - Беспарольная аутентификация на основе электронной почты</p>.
			<p>В предыдущем сценарии работы обратите внимание, что код OTP не попадает в веб-приложение до тех пор, пока пользователь не введет его. Валидация происходит в бэкенде, а не во фронтенде. Это делает наше приложение очень простым, поскольку ему нужно только сначала собрать письмо и отправить его на сервер, а затем в течение заданного времени ждать нового ввода. В сервисе или компоненте, использующем Axios, этот код будет выглядеть примерно так:</p> <pre class class source code.
			<pre class="source-code">const _user_email=ref(""),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_wait_seconds=ref(0),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_show_input_code=ref(false),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_otp_code=ref("")
function <b>signInUser()</b>{
&nbsp;&nbsp;&nbsp;&nbsp;axios.post("https://requestOTP_url",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>{email:_user_email.value</b>})
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(result=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_wait_seconds.value=result.data.wait_time;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_show_input_code.value=true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startOTPtimer();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}).catch(err=&gt;{...})
}
function <b>startOTPtimer()</b>{
&nbsp;&nbsp;&nbsp;let interval_id=setInterval(()=&gt;{
&nbsp;&nbsp;&nbsp;if(_wait_seconds.value&gt;0){_wait_seconds.value--;}
&nbsp;&nbsp;&nbsp;else{clearInterval(interval_id);}},1000)
}
function <b>checkOTP()</b>{
&nbsp;&nbsp;&nbsp;axios.post("https://validateOTP_URL",<b>{code:_otp_code.value}</b>)
&nbsp;&nbsp;&nbsp;.then(result=&gt;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(result.status&gt;200 &amp;&amp; result.status&lt;300){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>// Пользователь подтвержден, переходим к защищенному маршруту</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>// Валидация не прошла. Перенаправление на маршрут ошибок</b>.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 }).catch(err=&gt;{...})
}</pre>
			<p>В предыдущем коде мы опустили импорты и шаблон, так как на данном этапе они должны быть тривиальными для читателя. Наш шаблон должен содержать как минимум вход для сбора email пользователя, второй вход для сбора OTP-кода, а также две кнопки для запуска по щелчку функции <b>signInUser()</b> и функции <b>checkOTP()</b>. Первая передаст письмо на бэкенд и будет ждать ответа с указанием времени ожидания в секундах, которое мы используем для запуска таймера (всегда полезно сообщить пользователю, сколько времени у него есть для ввода кода). В настоящее время для электронных писем и текстовых сообщений стандартом является 60 секунд. Когда это происходит, мы также скрываем первый вход, а затем показываем форму ввода "OTP". Когда пользователь вводит код и нажимает <b>Submit</b>, активизируется функция <b>checkOTP()</b>, и мы снова передаем код на сервер, ожидая ответа. В случае успеха мы можем перенаправить пользователя в защищенную область в соответствии с логикой нашего приложения. Учитывая тривиальность шаблона, для читателя будет хорошим упражнением самостоятельно создать компонент и шаблон. Затем возможное решение можно найти в примерах кода в папке <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_05.xhtml#_idTextAnchor130"><i>Глава </i></span><span class="No-Break"><i>5</i></span></a><span class="No-Break">.
			<p>Следуя прогрессивному подходу к безопасности, следующим шагом является объединение предыдущих подходов в общий новый процесс: <b>двухфакторная аутентификация</b> (<b>2FA</b>), которую мы сейчас и рассмотрим.</p> <p>
			<h3>2FA - двухфакторная аутентификация</h3>
			<p>В случае 2FA наше приложение объединяет два или более предыдущих подхода для проверки пользователя. Ключевая концепция этого метода заключается в том, что даже третьего лица или простого имени пользователя и пароля недостаточно, и пользователю необходимо иметь "вторичный фактор" для проверки - например, использование зарегистрированной электронной почты, номера телефона (для отправки кодов по SMS), приложений для аутентификации (например, Google Authenticator), USB-устройства, карты безопасности (с чипом или считывателем полос) и т.д. </p> <p>Процесс работы прост.
			<p>Процесс работы прост, но требует от нашего бэкенда больше, чем от фронтенд-приложения. После того как SPA аутентифицирует пользователя с помощью любого из перечисленных ранее методов, на бэкенде запускается второй запрос для отправки соответствующего запроса на устройство безопасности. Предположим, что пользователь получает от нашего сервера SMS с кодом. Наш SPA будет ждать, собирать этот код в течение определенного промежутка времени (обычно 60 секунд) и отправлять его на бэкенд в определенную конечную точку. Именно сервер затем проверяет код. В реальности это похоже на наличие двух или нескольких паролей, проверка которых производится каскадно. Если какой-либо шаг окажется неудачным, то вся операция будет отменена.</p> <p>На рисунке показано, как происходит проверка паролей.
			<p> Вот визуализация этого процесса:</p>
			<div>
				<div>
					<img src="images/Figure_5.08_B18602.jpg" alt="Рисунок 5.8 - Упрощенный вид нашего SPA и серверного взаимодействия с 2FA" width="656" height="325">
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 5.8 - Упрощенный вид взаимодействия SPA и сервера с 2FA</p>.
			<p>Как видно из упрощенного рабочего процесса, процесс проверки пользователя с помощью 2FA (как и в случае с беспарольными и OTM-методами) зависит не столько от кода или специфической криптографии, сколько от использования продуманных средств коммуникации и изоляции данных. Данные и процесс проверки никогда не покидают наш сервер и не могут быть видны конечному пользователю, даже если открыть код нашего SPA. В некотором смысле этот рабочий процесс можно представить как объединение аутентификации по OpenID или учетным данным с последующей реализацией OTP.</p> <p>
			<p>Основная задача нашего приложения - собирать биты данных, составляющие каждый шаг, и передавать их на сервер. В промежутках между ними мы могли бы менять маршрут или обновлять интерфейс, но эта реализация тривиальна, поэтому конкретного кода мы здесь не увидим (как программно изменить маршрут, например, можно было посмотреть ранее).</p> <p> В этом случае мы не будем приводить конкретные примеры.
			<p>В целом 2FA считается "более безопасным методом", но он не лишен недостатков и может подойти не для всех приложений. Например, что произойдет, если вы знаете свое имя пользователя и пароль, но потеряете второе устройство (мобильный украдут, взломают и т.д.)? Организации, использующие этот метод, часто предоставляют возможность восстановления идентификационных данных, нередко с дорогостоящей реализацией (вспомните банк и телефонную службу). В итоге этот метод создает еще один уровень сложности в аутентификации пользователей, а вместе с ним и еще одну возможную точку отказа, что при неправильном подходе приводит к разочарованию пользователей.</p> <p>
			<p>Далее рассмотрим еще один метод аутентификации, который набирает обороты в качестве нового ребенка в блоке шаблонов аутентификации: Web3-аутентификация.</p> <p>
			<h3>Web3-аутентификация</h3>
			<p>Перед тем как перейти к рассмотрению этой темы, необходимо определить, что такое <b>Web3</b>. По всей видимости, существует некоторая путаница в определении, поэтому для наших целей Web3 считается следующей итерацией или эволюцией Интернета, где вычислительная мощность будет осуществляться на децентрализованных и распределенных серверах с использованием технологий блокчейн. Наиболее известными и популярными приложениями этих технологий в настоящее время являются криптовалюты, децентрализованные самоуправляемые организации, децентрализованные финансы, игры типа "играй и получай", распределенные облачные хранилища и многое другое.</p> <p>
			<p>Блокчейн (англ. <b>blockchain</b>) - это бухгалтерская книга, которая ведется сетью распределенных компьютеров. Все, что записывается в него, является неизменяемым и общедоступным для любого пользователя сети. Некоторые блокчейны являются "умными", то есть они могут содержать не только данные, но и запускать приложения, как и любой бэкэнд-сервис. Фронтенд-приложения, подключаемые к блокчейну, называются <b>распределенными приложениями (DApps</b>), которые в большинстве своем являются <i>SPA</i>. Для решения этой задачи, как мы уже убедились, очень хорошо подходит фреймворк Vue 3. DApp должен соединяться с внутренним сервером, который является частью целевой сети блокчейна. Такие серверы называются <b>узлами</b>. В некоторых случаях DApp может взаимодействовать непосредственно с блокчейном. Большинство, если не все, блокчейны используют криптовалюты для регулирования операций и вознаграждения узлов, поддерживающих сеть. Криптовалюты логически приписываются к уникальному идентификатору блокчейна, называемому "кошельком". В этих кошельках реализованы весьма интеллектуальные криптографические технологии, позволяющие подтверждать друг друга при выполнении операций с помощью открытых и закрытых ключей. У пользователя может быть множество кошельков. В блокчейне не существует электронной почты или способов восстановления утерянных ключей, и каждый кошелек уникален.</p> <p> В блокчейне не существует электронной почты или способов восстановления утерянных ключей.
			<p>Для того чтобы решить все эти проблемы с криптографическими знаками и валидацией, а также упростить работу пользователей, существуют специальные плагины для браузеров, называемые "цифровыми кошельками", а также мобильные приложения-кошельки, которые также реализуют просмотр веб-страниц. Эти приложения хранят учетные данные и выполняют всю работу с блокчейном. Конечно, существует множество библиотек для выполнения тех же задач на чистом JavaScript, но это выходит за рамки данной книги. Далее мы рассмотрим, как в нашем SPA мы можем использовать возможности этих технологий для идентификации пользователя даже автоматически при посещении страницы нашего приложения.</p> <p> Мы сосредоточимся на том, как сделать так, чтобы пользователь мог идентифицировать свою личность.
			<p>В качестве примера мы рассмотрим крупнейший смарт-блокчейн - сеть Ethereum. Аналогичный рабочий процесс с большим или меньшим количеством шагов применим и к другим сетям, использующим различные SDK, поэтому перенос или включение дополнительных блокчейнов не слишком далеко отстоит от наших примеров. Основной концептуальный рабочий процесс выглядит следующим образом:</p>
			<p>Импортируем библиотеку для подключения к сети на нашем JavaScript, либо через такие библиотеки, как <b>web3js</b> (<a href="https://www.npmjs.com/package/web3">https://www.npmjs.com/package/web3</a>), <b>ethjs</b><b> </b>(<a href="https://www.npmjs.com/package/ethjs">https://www.npmjs.com/package/ethjs</a>), либо использовать тот, который инжектируется непосредственно кошельком браузера - в нашем примере, <b>MetaMask</b>, в </span><span class="No-Break"><b>window.ethereum</b></b></p>.
			<ul>
				<li>Используя объект <b>ethereum</b>, мы запрашиваем у пользователя подключение его кошелька к нашему сайту и получаем адрес выбранного кошелька</li>.
				<li>После этого наше приложение может отправить на бэкэнд идентификатор кошелька (который является публичным) и использовать его в качестве уникального идентификатора учетной записи пользователя</li>.
			</ul>
			<p>Как уже было сказано, мы будем использовать объект, инжектированный <b>MetaMask</b> (https://metamask.io/), поскольку это один из наиболее известных браузерных кошельков. В данном случае здесь приведен код, запрашивающий кошелек текущего пользователя:</p>
			<pre class="source-code">ethereum
<b>.request({ method: 'eth_requestAccounts' })</b>
.then(
&nbsp;&nbsp;&nbsp;&nbsp;result=&gt;console.log(result[0]),
&nbsp;&nbsp;&nbsp;&nbsp;err=&gt;console.log(err)
)</pre>
			<p>Вот и все! Выделенная строка побуждает <i>MetaMask </i> открыть новое окно и запросить у пользователя разрешение на подключение его кошелька к вашему веб-приложению, а затем вернуть удобное обещание. В случае разрешения результатом будет массив строк, в котором первой позицией будет адрес кошелька для текущей сети. В случае отказа будет выдана ошибка.</p>
			<h6>Совет</h6>
			<p class="callout">При использовании MetaMask можно открыть в браузере <b>Инструменты разработчика</b> и набрать в одной строке приведенный ниже код для его тестирования.</p>
			<p>С помощью <b>MetaMask</b> тот же код для сети <b>Ethereum</b> также работает при подключении к сетям <b>Polygon</b> и <b>Binance Smart Chain</b> (три по цене одного!). Другие сети и кошельки, например кошелек Phantom, работают по тому же принципу и внедряют в объект <b>windows</b> новый объект <b>.solana</b>. Ознакомьтесь с документацией по целевому блокчейну, чтобы узнать подробности каждой реализации.</p> <p>Взаимодействие с блокчейном.
			<p>Взаимодействие с каждым блокчейном и его кодом выходит за рамки данной книги, поэтому мы ограничимся идентификацией пользователя по адресу его кошелька. Получив эту идентификацию, логика приложения должна сохранить ее для дальнейшего использования, поскольку она действует как идентификатор пользователя.</p> <p> Существуют и сторонние блокчейны.
			<p>Для аутентификации и взаимодействия с несколькими блокчейнами существуют также решения сторонних разработчиков, и нам следует рассмотреть их, прежде чем реализовывать собственное решение.</p>
			<h2>Обзор</h2>
			<p>В этой главе мы значительно улучшили наше приложение и создали продуманный SPA с навигацией с помощью маршрутизатора Vue. Это важная концепция, позволяющая сегментировать приложение и организовать работу между членами команды разработчиков. Фракционирование приложения по пути навигации упрощает разработку и сопровождение и делает их более организованными. Мы также изучили несколько стандартных паттернов аутентификации, которые можно использовать в наших приложениях. Они охватывают большое количество сценариев, используемых сегодня в индустрии, начиная от самых простых имени пользователя и пароля и заканчивая новыми Web3 DApps. Мы также уделили время тому, как работают стандартные протоколы, такие как OAuth, а также OTP, и как они могут быть реализованы для дополнительного уровня безопасности в качестве второго фактора аутентификации. Все эти навыки актуальны и необходимы для современных стандартов веб-приложений.</p> <p> В следующей главе мы рассмотрим, как работают стандартные протоколы, такие как OAuth, OTP, и как их реализовать для дополнительного уровня безопасности в качестве второго фактора аутентификации.
			<p>В следующей главе мы продолжим расширять наши технические знания, познакомившись с <b>прогрессивными веб-приложениями</b><b> (</span><span class="No-Break">).</p> <h>В следующей главе мы познакомимся с <b>прогрессивными веб-приложениями</b><b> (</span><span class="No-Break"><b>PWAs</b></span><span class="No-Break">).
			<h2>Вопросы</h2>
			<p>В этой главе мы рассмотрели множество различных тем и ввели новые понятия. Используйте следующие вопросы, чтобы закрепить полученные знания:</p>
			<ul>
				<li>Когда лучше использовать SPA вместо MPA и наоборот? </li>
				<li>Каковы преимущества использования маршрутизатора в SPA? Назовите не менее трех из собственного анализа.</li> <li>
				<li>Как можно использовать представления для определения компоновки приложения?</li>
				<li>Как можно получить доступ к параметрам и строке запроса, переданным маршруту, в JavaScript?</li>
				<li>Каковы некоторые общие стандартные шаблоны для аутентификации пользователей?</li>
				<li>Каковы некоторые соображения безопасности при аутентификации пользователей в SPA? </li>
			</ul>
		</div>
	</div></div>