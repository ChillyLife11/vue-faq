 			<h1>Управление потоками данных</h1> <p>В предыдущих главах мы сосредоточились на понимании фреймворка Vue 3 и создании контекста для создания веб-приложений. В этой главе мы сосредоточимся на том, как наши компоненты взаимодействуют друг с другом и обмениваются информацией для реализации нашего приложения. Ранее мы уже вкратце касались этой темы, но теперь мы глубоко погрузимся в некоторые паттерны, реализуя их рядом друг с другом. Применение соответствующего информационного рабочего процесса - важный навык, который может сделать или разрушить приложение. В частности, мы рассмотрим следующие подходы и <span class="No-Break">примеры кода:</span></p> <ul> <li><span class="No-Break">Общение между родителями, детьми и братьями</span></li> <li>Реализация шины сообщений с использованием <strong class="bold">Singleton </strong>и <span class="No-Break"><strong class="bold">Observer </strong></span><span class="No-Break">паттернов</span></li> <li>Реализация базового реактивного состояния с помощью <span class="No-Break">композитных компонентов</span></li> <li>Реализация централизованного хранилища данных с помощью мощного хранилища Pinia <span class="No-Break">reactive store</span></li> <li>Обзор предоставляемых браузерами альтернатив для обмена и <span class="No-Break">хранения информации</span></li> <li>Эксперименты с реактивностью, реактивностью, составными элементами и паттернами прокси <span class="No-Break">в действии</span></li> </ul> <p>Как мы уже делали ранее, мы будем строить по одной концепции за раз, увеличивая сложность. К концу этой главы вы увидите наглядные примеры реализации, и сможете решить, когда применять каждую из них, исходя из потребностей вашего приложения. Некоторые из них больше подходят для небольших приложений, а другие - для больших и сложных. Вы будете лучше подготовлены к управлению потоком информации для <span class="No-Break">вашего приложения.</span></p> <h1>Технические требования</h1> <p>В этой главе мы рассмотрим концепции и применим паттерны для управления связью и потоком информации между компонентами. Вы должны быть в состоянии выполнить код, представленный в этом тексте, но для лучшего понимания и контекстного опыта вам будет полезно ознакомиться с полным кодом приложения для этой главы, доступным в репозитории к этой <span class="No-Break">книге: </span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter07"><span class="No-Break">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter07</span></a><span class="No-Break">.</span></p> <p>Если вы начинаете новый проект, просто следуйте инструкциям по созданию леса, как показано в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_03.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic">Глава 3</em></span></a>, <em class="italic">Setting Up a </em><span class="No-Break"><em class="italic">Working Project</em></span><span class="No-Break">.</span></span></p> <p>Посмотрите следующее видео, чтобы увидеть Код в <span class="No-Break">действии: </span><a href="https://packt.link/ZKTBJ"><span class="No-Break">https://packt.link/ZKTBJ</span></a></p> <h1>Основное взаимодействие компонентов</h1> <p>Ранее мы видели, что родительский компонент и его дочерние компоненты имеют довольно простой и понятный способ взаимодействия. Родители передают данные в виде <strong class="source-inline">параметров</strong> своим дочерним компонентам, а те поднимают события (<strong class="source-inline">emits</strong>), чтобы привлечь внимание родителя. Подобно сопоставимости параметров и аргументов в функциях, <strong class="source-inline">предметы</strong> получают простые данные по копии, а сложные типы (объекты, массивы и т.д.) - по ссылке. Таким образом, мы можем передать от родителя к ребенку обычный объект с функциями-членами, а ребенок будет выполнять эти функции для доступа к данным родителя. Несмотря на то, что это "работает", это своего рода темный паттерн или антипаттерн, поскольку он скрывает отношения и затрудняет понимание потока данных. Правильным способом передачи данных вверх по дереву компонентов являются события (<strong class="source-inline">emits</strong>).  При этом следует отметить, что дочерние компоненты "не знают" друг друга, то есть не имеют прямого способа взаимодействия между собой. Мы можем передать реактивную переменную и заставить каждый компонент обращаться к ней, и это, конечно, рабочая альтернатива, если не чистая. В некоторых случаях это дает простое решение, но опять же может привести к скрытым <span class="No-Break">побочным эффектам.</span></span></p> <p> Для того чтобы управлять рабочим процессом данных чистым способом, у нас есть несколько альтернатив, которые следуют хорошей практике и паттернам проектирования. Как общее правило и принцип, компонент, объявивший переменную, является ее владельцем, и именно он должен манипулировать ею. Исходя из этого, при самом базовом взаимодействии информация должна храниться и манипулироваться родительским компонентом и передаваться дочерним. Для распространения информации мы можем использовать реактивную систему Vue. Ключевым моментом здесь является то, что манипулировать ею будет только родительский компонент. Посмотрим, как это работает на практике, на примере реализации небольшого тривиального приложения, как показано на <span class="No-Break"><em class="italic">Рисунке 7</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p> <div> <div id="_idContainer049" class="IMG---Figure"> <img src="Chapter%20777%20Data%20Flow%20Management%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_7.01_B18602.jpg" alt="Рисунок 7.1 - Прямая базовая коммуникация и реактивность" width="536" height="155"> </div> </div> <p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 7.1 - Прямая базовая связь и реактивность</p> <p>В данном приложении родительский компонент имеет три прямых дочерних компонента и разделяет с ними реактивный счетчик. Все компоненты отображают метку со значением счетчика и имеют кнопку для запуска инкремента... но только родительский компонент выполняет фактические манипуляции с данными. Vue обеспечивает реактивность, то есть когда родительский компонент изменяет значение, дочерние компоненты также получают его. Все достаточно просто - давайте посмотрим, как реализовано это <span class="No-Break">:</span></p> <p class="SC---Heading" lang="en-US" xml:lang="en-US">/basic/ParentBasic.vue</p> <div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code"> &lt;script setup&gt; import {ref} from "vue" import ChildComponent from "./Child.vue" const <strong class="bold">_counter</strong> = ref(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<strong class="bold">//1</strong> function <strong class="bold">incrementCounter()</strong> {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//2</strong> &nbsp;&nbsp;&nbsp;_counter.value++; } &lt;/script&gt; &lt;template&gt; &lt;div&gt; &nbsp;&nbsp;&nbsp;&lt;strong&gt;Счетчик &lt;/strong&gt; &nbsp;&nbsp;&lt;span&gt;{{ _counter }}&lt;/span&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;кнопка <strong class="bold">@click="incrementCounter()"</strong>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//3</strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Увеличение &nbsp;&nbsp;&nbsp;&lt;/button&gt; &lt;/div&gt; &lt;section&gt; &lt;ChildComponent title="Child component 1" &nbsp;&nbsp;<strong class="bold">:counter="_counter" @increment="incrementCounter()"</strong>&gt;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//4</strong> &lt;/ChildComponent&gt; &lt;ChildComponent title="Child component 2" &nbsp;&nbsp;<strong class="bold">:counter="_counter" @increment="incrementCounter()"</strong>&gt; &lt;/ChildComponent&gt; &lt;ChildComponent title="Child component 3" &nbsp;&nbsp;<strong class="bold">:counter="_counter"</strong> <strong class="bold">&nbsp;&nbsp;@increment="incrementCounter()"</strong>&gt;&lt;/ChildComponent&gt; &lt;/section&gt; &lt;/template&gt;</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div> <p>В этом компоненте, мы объявляем реактивную переменную <strong class="source-inline">_counter</strong> (строка <strong class="source-inline">//1</strong>) и функцию <strong class="source-inline">incrementCounter()</strong> для работы с ее значением (строка <strong class="source-inline">//2</strong>). Мы запускаем эту функцию в родительской кнопке по событию click, как показано в строке <strong class="source-inline">//3</strong>. Теперь, чтобы увидеть реализацию этого паттерна, мы просто передаем нашу реактивную переменную <strong class="source-inline">_counter</strong> в качестве prop каждому дочернему компоненту, и связываем нашу функцию <strong class="source-inline">incrementCounter()</strong> с событием инкремента каждого дочернего компонента (строка <strong class="source-inline">//4</strong>). Все достаточно просто - давайте посмотрим, как каждый ребенок реализует <span class="No-Break">свою часть:</span></p> <p class="SC---Heading" lang="en-US" xml:lang="en-US">/basic/Child.vue</p> <div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code"> &lt;script setup&gt; const <strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;$props=defineProps(['counter', 'title'])</strong>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1 <strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;$emit=defineEmits(['increment'])</strong> function incrementCounter(){$emit("increment")}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2 &lt;/script&gt; &lt;template&gt; &lt;h3&gt;{{$props.title}}&lt;/h3&gt; &lt;span class="badge"&gt;<strong class="bold">{{$props.counter}}</strong>&lt;/span&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3 &lt;button<strong class="bold"> @click="incrementCounter()"</strong>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increment &lt;/button&gt; &lt;/template&gt;</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div> <p>Наша дочерняя реализация также проста. Начнем с определения реквизита для получения переменной counter в строке <strong class="source-inline">//1</strong>, а также нашего пользовательского события <strong class="source-inline">increment</strong>, чтобы мы могли уведомить родителя. Для этого мы создаем функцию в строке <strong class="source-inline">//2</strong>. В нашем шаблоне мы отображаем наш реквизит в строке <strong class="source-inline">//3</strong> и запускаем нашу функцию инкремента в строке <strong class="source-inline">//4</strong>.  Обратите внимание, что наш дочерний компонент не изменяет счетчик. За это отвечает компонент-отец, поэтому мы соблюдаем <span class="No-Break">шаблон.</span></span></p> <p>Этот шаблон мы будем использовать довольно часто, но у него есть некоторые ограничения. Например, что произойдет, если данные должны попасть к родителю, брату или внуку?  Будем ли мы передавать данные вверх и вниз по дереву, даже если компоненты их не используют? Можно, но, опять же, это грязно, многословно и не самый лучший способ.  У нас есть более эффективные средства <span class="No-Break">для этого.</span></p> <p>В <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_04.xhtml#_idTextAnchor102"><span class="No-Break"><em class="italic">глава 4</em></span></a>, <em class="italic">Композиция пользовательского интерфейса с помощью компонентов</em>, мы видели, что родитель может передавать данные и функциональность любому из своих дочерних элементов по дереву, используя <strong class="bold">инъекцию зависимостей</strong> (<strong class="bold">DI</strong>) с <strong class="source-inline">provide</strong> и <strong class="source-inline">inject</strong>.  Поскольку приведенный там пример был достаточно полным, мы не будем повторять его здесь. Я рекомендую вам просмотреть, как создавалось и вводилось обеспечение. Вместо того чтобы повторяться, давайте перейдем к следующему пункту нашей программы по обмену информацией в любом месте дерева компонентов: реализуем шину сообщений <strong class="bold">message bus</strong> (также называемую <span class="No-Break"><strong class="bold">event bus</strong></span><span class="No-Break">).</span></span></p> <h1>Реализация шины событий с помощью паттернов Singleton и Observer</h1> <p>Шина сообщений - это реализация паттерна <em class="italic">Observer</em>, который мы рассматривали в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_02.xhtml#_idTextAnchor040"><span class="No-Break"><em class="italic">главе 2</em></span></a>, <em class="italic">Принципы и паттерны проектирования программного обеспечения</em>. Кратко напомним основную концепцию: мы стремимся создать объект или структуру, принимающую и выдающую события, на которые могут подписываться и реагировать наши компоненты. Этот паттерн работает независимо от древовидной структуры компонентов, поэтому любой <em class="italic">компонент и сервис</em> может его использовать. Визуально мы можем представить получившуюся связь <span class="No-Break">следующим образом:</span></p> <div> <div id="_idContainer050" class="IMG---Figure"> <img src="Chapter%20777%20Data%20Flow%20Management%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_7.02_B18602.jpg" alt="Figure 7.2 - Упрощенный вид отношений шины сообщений с компонентами" width="590" height="147"> </div> </div> <p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 7.2 - Упрощенный вид отношений шины сообщений с компонентами</p> <p>Из приведенной диаграммы сразу видно, что каждый компонент воспринимается шиной сообщений одинаково. Каждый компонент подписывает один или несколько своих методов на определенное событие и в то же время имеет такую же возможность опубликовать событие. Это делает ее очень гибкой, поскольку события могут также <span class="No-Break">транспортировать данные.</span></p> <p>Давайте сведем эти понятия к коду на примере реализации. Начнем с создания сервиса, использующего паттерн Singleton, который предоставит нам шину сообщений. В нашем случае мы просто обернем пакет <strong class="source-inline">mitt</strong>, который предоставляет нам эту функциональность (<span class="No-Break">см. </span><span class="No-Break">https://github.com/developit/mitt#usage</span><span class="No-Break">).</span></p> <p> Пакет <strong class="source-inline">mitt</strong> может быть установлен в наше приложение с помощью следующей команды в <span class="No-Break">терминале:</span></p> <div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="console"> $ npm install mitt</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div> <p>Тогда наш сервис будет выглядеть <span class="No-Break">например так:</span></p> <p class="SC---Heading" lang="en-US" xml:lang="en-US">/services/MessageBus.js</p> <div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code"> import mitt from "mitt" const messageBus = mitt() export default messageBus</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div> <p>Это даст нам синглтон для эмиттера событий и диспетчера, то есть нашей шины сообщений. В нашем примере мы будем отправлять через нее текстовые сообщения, а каждый принимающий компонент будет их отображать. Наши компоненты будут выглядеть следующим образом:</span></p> <p class="No-Break">примерно так:</span></p> <p class="SC---Heading" lang="en-US" xml:lang="en-US">/bus/Child.vue</p> <div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code"> &lt;script setup&gt; import <strong class="bold">messageBus </strong>from './services/MessageBus';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//1</strong> import {ref, onMounted, onBeforeUnmount} from 'vue';  const &nbsp;&nbsp;&nbsp;$props=defineProps(['title']), &nbsp;&nbsp;&nbsp;<strong class="bold">message=ref("")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//2</strong> &nbsp;&nbsp;&nbsp;&nbsp;onMounted(()=&gt;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">messageBus.on(</strong>"message", showMessage)})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//3</strong> &nbsp;&nbsp;&nbsp;&nbsp;onBeforeUnmount(()=&gt;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">messageBus.off(</strong>"message",showMessage)}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function <strong class="bold">showMessage</strong>(value){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//4</strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message.value=value;} &nbsp;&nbsp;&nbsp;&nbsp;function <strong class="bold">sendMessage</strong>(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//5</strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;messageBus.emit("message",`Отправлено ${$props.title}`)} &lt;/script&gt; &lt;template&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;h4&gt;{{$props.title}}&lt;/h4&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;strong&gt;Получено: &lt;/strong&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;{{message}}&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;button <strong class="bold">@click="sendMessage()"</strong>&gt;Отправить сообщение&lt;/button&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//6</strong> &lt;/template&gt;</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div> <p>В этом примере мы начинаем со строки <strong class="source-inline">//1</strong>, импортируя наш объект <strong class="source-inline">messageBus</strong> (проверьте правильность пути в вашей реализации) и объявляя реактивную переменную <strong class="source-inline">message</strong>, инициализированную пустой строкой. Обратите внимание, что мы также импортируем и используем методы <strong class="source-inline">onMounted()</strong> и <strong class="source-inline">onBeforeUnmount()</strong> из жизненного цикла компонента для подписки и отписки на событие <strong class="source-inline">message</strong>, начиная со строки <strong class="source-inline">//3</strong>. Функция, которую мы регистрируем, находится в строке <strong class="source-inline">//4</strong>, и она получает от события значение, которое мы передаем нашей внутренней переменной для отображения в шаблоне. Также нам необходима функция для публикации события с целью оповещения других пользователей, которая находится в строке <strong class="source-inline">//5</strong>. В данном случае мы публикуем заголовок компонента. Эта функция вызывается кнопкой, как показано в <span class="No-Break">строке </span><span class="No-Break"><strong class="source-inline">//6</strong></span><span class="No-Break">.</span></p> <p>Если запустить пример приложения с дополнительным минимальным оформлением, то этот код приведет к чему-то <span class="No-Break">подобному:</span></p> <div> <div id="_idContainer051" class="IMG---Figure"> <img src="Chapter%20777%20Data%20Flow%20Management%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_7.03_B18602.jpg" alt="Рисунок 7.3 - Простая реализация совместного использования данных с помощью паттерна Observer" width="941" height="390"> </div> </div> <p class="IMG---Caption" lang="en-US" xml:lang="en-US">Фигура 7.3 - Простая реализация совместного использования данных с помощью паттерна Observer</p> <p>Этот подход к управлению потоком данных достаточно эффективен, но имеет и свои ограничения. События - это хороший способ одновременного оповещения нескольких компонентов для запуска действий, независимо от их места в дереве организации. Если в приложении имеется несколько подсистем, которые должны реагировать на изменение состояния приложения, то такой паттерн будет вполне уместен. Однако при работе в основном с данными приложения этот паттерн имеет существенный недостаток: каждый компонент хранит внутреннюю копию информации. Это делает работу с памятью весьма неэффективной, поскольку распространение данных означает их копирование в разные части нашего приложения. Есть случаи, когда это необходимо или желательно, но, конечно, не для каждого случая. Если у нас 50, 100 или 1000 компонентов, подписанных на одно и то же событие, будут ли все они иметь одну и ту же копию данных? Если каждый компонент должен обрабатывать и, возможно, модифицировать данные независимо от других, то это работает хорошо... Но если мы хотим лучше использовать реактивность Vue и улучшить работу с памятью, то нам нужно использовать другой подход. Именно это мы и увидим на примере базового реактивного <span class="No-Break">состояния приложения.</span></p> <h1>Реализация базового реактивного состояния</h1> <p>Как уже упоминалось, недостатком использования шины сообщений для обмена данными является множественность копий одних и тех же данных, включая накладные расходы на обработку событий.  Вместо этого мы можем использовать механизм реактивности Vue и, в частности, вспомогательный конструктор <strong class="source-inline">reactive()</strong> для создания единой сущности, хранящей состояние нашего приложения. Как и раньше, мы можем обернуть этот реактивный объект в паттерн Singleton, чтобы использовать его совместно с компонентами и обычными JavaScript-функциями, объектами и классами.  Стоит отметить, что это одно из главных преимуществ Vue 3 и нового <span class="No-Break">Composition API.</span></span></p> <p>В завершение мы рассмотрим базовый код <span class="No-Break">примерно так:</span></p> <div> <div id="_idContainer052" class="IMG---Figure"> <img src="Chapter%20777%20Data%20Flow%20Management%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_7.04_B18602.jpg" alt="Рисунок 7.4 - Общий реактивный объект для управления состоянием" width="514" height="187"> </div> </div> <p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 7.4 - Общий реактивный объект для управления состоянием</p> <p>Как видно на предыдущем снимке экрана, состояние в данном случае является общим (или доступным) для всех компонентов данного примера. Любой из дочерних компонентов может изменить любое из его значений, и это изменение немедленно отражается на всем приложении. В отличие от предыдущих примеров, реализация данного паттерна проста и понятна. Давайте погрузимся в нее, создав сначала сервис с нашим <span class="No-Break">реактивным состоянием:</span></p> <p class="SC---Heading" lang="en-US" xml:lang="en-US">/service/SimpleState.js</p> <div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code"> import {reactive} from "vue"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1 const _state=reactive({counter: 0})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2 function useState(){return _state;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3 export default useState;</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div> <p>Если этот код кажется простым, то это так и есть. Мы создаем JavaScript-файл и импортируем конструктор <strong class="source-inline">reactive</strong> из Vue (строка <strong class="source-inline">//1</strong>). Затем мы объявляем реактивную константу с начальным объектом (строка <strong class="source-inline">//2</strong>). Это будет состояние приложения, которое мы возвращаем через функцию <strong class="source-inline">useState()</strong>, названную по модели композитных компонентов (строка <strong class="source-inline">//3</strong>). Эта функция является нашим <span class="No-Break">экспортом модуля.</span></p> <p>Использование этого централизованного состояния также очень просто, как мы можем <span class="No-Break">увидеть здесь:</span></p> <p class="SC---Heading" lang="en-US" xml:lang="en-US">/simple/ChildSimple.vue</p> <div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code"> &lt;script setup&gt; &nbsp;&nbsp;&nbsp;&nbsp;import <strong class="bold">useState </strong>from "../.../services/SimpleState"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1 &nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">const $state=useState()</strong> &lt;/script&gt; &lt;template&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;strong&gt;State: &lt;/strong&gt;&lt;br&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;pre&gt;<strong class="bold">{{$state}}</strong>&lt;/pre&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;button <strong class="bold">@click="$state.counter++"</strong>&gt;Increment&lt;/button&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3 &nbsp;&nbsp;&nbsp;&nbsp;&lt;button @click="$state.counter--"&gt;Decrement&lt;/button&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &lt;/template&gt;</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div> <p>Начнем наш компонент с импорта фабричной функции <strong class="source-inline">useState</strong> и объявим с ее помощью реактивную константу (строка <strong class="source-inline">//1</strong>). Мы используем эту реактивную переменную в нашем шаблоне так же, как и любую другую (строка <strong class="source-inline">//2</strong>), и точно так же можем напрямую обращаться к полям-членам объекта для их модификации, как и в случае с любым другим объектом, как это показано в строке <strong class="source-inline">//3</strong>. После этого, как и следовало ожидать, как только компонент изменяет какое-либо значение, это изменение распространяется по всему приложению <span class="No-Break">.</span></p> <p>Этот простой подход очень полезен и подходит для небольших и даже средних приложений. Он имеет много преимуществ, таких как <span class="No-Break">следующие:</span></p> <ul> <li>Простота реализации <span class="No-Break">и понимания.</span></li> <li>Используется <span class="No-Break">реактивная система Vue.</span></li> <li>Она гибкая, поскольку мы можем добавлять новые реактивные члены <span class="No-Break">после инициализации.</span></li> <li>Она создает единый источник истины, то есть наше состояние является централизованным хранилищем данных приложения. Нет необходимости синхронизировать внутренние или приватные <span class="No-Break">переменные.</span></li> </ul> <p>Если рассматривать рассмотренные до сих пор варианты, то это гигантский скачок вперед. Однако есть ситуации, когда эти <span class="No-Break">недостатки:</span></p> <ul> <li>Что происходит, когда функция изменяет свое значение асинхронным способом, если другие компоненты внесли изменения до того, как <span class="No-Break">была решена эта проблема?</span></li> <li>Этот подход не позволяет нам работать с вычисляемыми данными, которые должны быть реализованы в <span class="No-Break">каждом компоненте</span></li> <li>Отладка может быть затруднена, поскольку нет специальной поддержки <span class="No-Break">инструментов разработчика</span></li> </ul> <p>Как уже было сказано, этот подход подходит для простых нужд. Для более надежного подхода мы обратимся к официальному решению централизованного управления состоянием от проекта Vue <span class="No-Break">: </span><span class="No-Break"><strong class="bold">Pinia</strong></span><span class="No-Break">.</span></p> <h1>Implementing a powerful reactive store with Pinia</h1> <p>Центральное управление состоянием не является концепцией, присущей только Vue, и аналогичный паттерн можно встретить в других библиотеках и фреймворках. Как и в нашем базовом реактивном примере, <strong class="bold">Pinia</strong> - это центральный инструмент управления состоянием, который предоставляет нам единый источник истины, что означает, что изменение одного из его значений будет реактивно распространяться на все приложение, где бы оно ни использовалось. Это состояние разделяется между компонентами приложения и дает нам доступ ко всему спектру реактивных инструментов, предоставляемых Vue, через четко определенный интерфейс. Понять суть Pinia будет проще, если сначала мы построим пример, демонстрирующий результаты его использования. Запуск кода примера даст нам нечто <span class="No-Break">подобное этому:</span></p> <div> <div id="_idContainer053" class="IMG---Figure"> <img src="Chapter%20777%20Data%20Flow%20Management%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_7.05_B18602.jpg" alt="Figure 7.5 - Центральное управление состоянием с помощью Pinia" width="646" height="275"> </div> </div> <p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 7.5 - Центральное управление состоянием с помощью Pinia</p> <p>В этом примере мы строим магазин, который не только отображает реактивное состояние, но и реализует вычисляемые значения. Как официально поддерживаемый проект, Pinia также предоставляет реализации API Options и Composition. Чтобы использовать Pinia, нам необходимо включить его в наш проект с помощью следующей команды в <span class="No-Break">корневом каталоге проекта:</span></p> <div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code"> $ npm install pinia</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div> <p>После установки нам необходимо создать магазин и прикрепить его к нашему приложению, чтобы он мог использоваться всеми компонентами. Магазин - это как наш реактивный синглтон из предыдущего раздела, то есть объект, который будет содержать реактивные поля, разделяемые в нашем приложении, а также соответствующую бизнес-логику. Итак, каждый магазин будет содержать следующие элементы: <strong class="source-inline">данные</strong>, вычисляемые свойства, известные как <strong class="source-inline">геттеры</strong>, и методы, известные как <strong class="source-inline">действия</strong>. Каждый магазин мы определяем в отдельном файле как модуль, определяя каждый элемент. При использовании API Options магазин будет выглядеть <span class="No-Break">как здесь:</span></p> <p class="SC---Heading" lang="en-US" xml:lang="en-US">Options API basic store</p> <div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code"> import { <strong class="bold">defineStore </strong>} from 'pinia';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1 const <strong class="bold">useCounterStore </strong>= defineStore(<strong class="bold">'counter'</strong>, {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2 &nbsp;&nbsp;<strong class="bold">state</strong>: () =&gt; {return <strong class="bold">{count: 0, in_range: false}</strong>},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3 &nbsp;&nbsp;<strong class="bold">getters</strong>: { &nbsp;&nbsp;&nbsp;&nbsp;doubleCount: (state) =&gt; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(state.count&gt;=0){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return state.count *2; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;}, inRange: (state)=&gt;return state.count&gt;=0}, &nbsp;&nbsp;<strong class="bold">действия</strong>: {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//5 &nbsp;&nbsp;&nbsp;&nbsp;increment(){this.count++}, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decrement(){this.count--;} &nbsp;&nbsp;}, }) export {<strong class="bold">использование магазина CounterStore}</strong></pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div> <p>В этом магазине, мы начинаем с импорта конструктора <strong class="source-inline">defineStore</strong> из пакета <strong class="source-inline">Pinia </strong> (строка <strong class="source-inline">//1</strong>) и используем его для создания магазина в строке <strong class="source-inline">//2</strong>. Этот конструктор получает <span class="No-Break">два аргумента:</span></span></p> <ul> <li>Имя магазина в виде строки. Оно должно быть уникальным среди магазинов, так как используется внутри магазина в качестве <span class="No-Break">идентификатора.</span></li> <li>Объект, содержащий определение магазина с <span class="No-Break">следующими членами:</span><ul><li><strong class="source-inline">state</strong> (строка <strong class="source-inline">//3</strong>): Это функция, возвращающая объект. Обратите внимание, что мы не объявляем ее реактивной. Pinia позаботится <span class="No-Break">об этом.</span></li><li><strong class="source-inline">getters</strong> (строка <strong class="source-inline">//4</strong>):  Это объект, члены которого станут вычисляемыми свойствами. Каждый член получает в качестве первого аргумента состояние магазина, как <span class="No-Break">реактивный объект.</span></li><li><strong class="source-inline">actions</strong> (строка <strong class="source-inline">//5</strong>):  Это опять же объект, членами которого являются функции, которые могут получать доступ к состоянию и изменять его, но должны делать это через ключевое слово <span class="No-Break"><strong class="source-inline">this</strong></span><span class="No-Break">.</span></li></ul></li> </ul> <p>Использование API Options для определения магазина - хороший способ понять, из каких частей он состоит. Однако изменение синтаксиса между <strong class="source-inline">getters</strong> и <strong class="source-inline">actions</strong> может запутать и привести к непроизвольным ошибкам, поскольку в одном случае доступ к состоянию осуществляется через аргумент, а в другом - с помощью ссылки <strong class="source-inline">this</strong>. Однако если мы немного посмотрим на конструктор, то увидим, что <strong class="source-inline">getters</strong> и <strong class="source-inline">actions</strong> являются аналогами <em class="italic">вычисляемых свойств и методов компонента</em> (функций). Учитывая это, давайте посмотрим, как переписать этот магазин с помощью Composition API, и именно его мы будем использовать в нашем <span class="No-Break">примере кода:</span></p> <p class="SC---Heading" lang="en-US" xml:lang="en-US">/stores/counter.js</p> <div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code"> //Composition API <strong class="bold">import {ref,computed} from 'vue'</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1 import {defineStore} from 'pinia' const useCounterStore=defineStore('counter',<strong class="bold">()=&gt;{</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count = ref(0),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in_range=ref(true), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doubleCount = computed(() =&gt; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(count.value&gt;=0){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return count.value *2; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}}), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inRange = computed(()=&gt;return count.value&gt;=0); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function increment() {count.value++}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function decrement(){count.value--;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//6 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count, doubleCount, inRange, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;инкремент, декремент &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}  <strong class="bold">})</strong></pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div> <p>Использование Composition API делает магазин более похожим на остальное приложение, поскольку мы применяем один и тот же подход. Мы начинаем с импорта из Vue необходимых нам конструкторов в строке <strong class="source-inline">//1</strong>, как и в случае с компонентами, использующими тот же API. На этот раз, когда мы используем конструктор <strong class="source-inline">defineStore</strong>, вместо объекта мы передаем функцию (или функцию-стрелку), которая вернет реактивные свойства и методы, составляющие магазин. Это можно увидеть в строке <strong class="source-inline">//2</strong>, а затем объект <strong class="source-inline">return</strong> в строке <strong class="source-inline">//6</strong>. Как и следовало ожидать, внутри этой функции мы объявляем наши реактивные свойства (строка <strong class="source-inline">//3</strong>) и вычисляемые свойства (строка <strong class="source-inline">//4</strong>), а также методы (строка <strong class="source-inline">//5</strong>).  Реактивные свойства станут просто реактивными свойствами. Вычисляемые свойства станут нашими геттерами, а функции - действиями. Пока в этом синтаксисе нет того синтаксического сахара, к которому мы привыкли, используя тег <strong class="source-inline">&lt;script setup&gt;</strong>, но тело функции - это тот же подход (состояние ума), который мы используем <span class="No-Break">с компонентами.</span></p> <p>Когда у нас есть магазин (а их может быть много), прежде чем мы сможем реально его использовать, нам нужно реализовать Pinia в нашем приложении. Для этого в наш файл <strong class="source-inline">main.js</strong> включите следующие <span class="No-Break">выделенные строки:</span></p> <p class="SC---Heading" lang="en-US" xml:lang="en-US">./main.js</p> <div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code"> import { createApp } from 'vue' <strong class="bold">import { createPinia } from 'pinia'</strong> import App from './App.vue' const app = createApp(App) <strong class="bold">app.use(createPinia())</strong> app.mount('#app')</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div> <p>Этот шаг необходим для включения движка Pinia для всего приложения.  Теперь осталось импортировать магазин, который мы хотим использовать в компонентах, нуждающихся в нем. Например, если заглянуть в репозиторий примеров, то можно найти <span class="No-Break">этот файл:</span></span></p> <p class="SC---Heading" lang="en-US" xml:lang="en-US">/pinia/ChildPinia.vue</p> <div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code"> &lt;script setup&gt; import { <strong class="bold">useCounterStore </strong>} from '.././stores/counter';&nbsp;&nbsp;&nbsp;//1 const <strong class="bold">$store=useCounterStore()</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//2</strong> &lt;/script&gt; &lt;template&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h4&gt;Child component&lt;/h4&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;code :class="{'red': !<strong class="bold">$store.in_range</strong>}"&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{$store}} &nbsp;&nbsp;&nbsp;&nbsp;&lt;/code&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;button @click="<strong class="bold">$store.increment()</strong>"&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increment&lt;/button&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;button @click="$store.decrement()" &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:disabled="!$store.in_range"&gt;Decrement&nbsp;&nbsp;&nbsp;&nbsp;&lt;/button&gt; &lt;/template&gt; &lt;style scoped&gt; .red{color: red;} &lt;/style&gt;</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div> <p>В строке <strong class="source-inline">//1</strong> мы импортируем конструктор магазина, а в строке <strong class="source-inline">//2</strong> создаем наш реактивный объект. Чтобы использовать их значения или выполнить их методы, мы используем их напрямую, как если бы это были обычные объекты, используя нотацию точки (<strong class="source-inline">.</strong>). Обратите внимание, как в строке <strong class="source-inline">//3</strong> мы обращаемся к значению <strong class="source-inline">in_range</strong>, а позже, в строке <strong class="source-inline">//4</strong>, выполняем функцию <strong class="source-inline">increment()</strong>. Как и следовало ожидать, любое изменение значений хранилища будет автоматически синхронизировано по всему <span class="No-Break">нашему приложению.</span></span></p> <p>В отличие от предыдущих методов, хранилища и состояния Pinia отслеживаются и отображаются в инструментах разработчика. Для приложений среднего размера и выше использование Pinia является практически обязательным условием, когда необходимо центральное состояние <span class="No-Break">.</span></p> <p>Pinia является официальным решением Vue 3 для центрального управления состояниями, заменив Vuex из ветки Vue 2. На практике они реализуют одинаковую функциональность, но у первого есть ряд преимуществ, которые заставили команду Vue выбрать его и спонсировать. Глубокий обзор - не тема для наших целей, но вот краткий список изменений или преимуществ <span class="No-Break"> Pinia:</span></p> <ul> <li>Другой подход к магазинам. В Pinia каждый магазин - это отдельный модуль, и все они динамические. В Vuex вместо этого используется один единственный магазин с разделами <span class="No-Break">в модулях.</span></li> <li>Синтаксис и API для Pinia проще и менее многословны <span class="No-Break">по сравнению с Vuex.</span></li> <li>Улучшена поддержка TypeScript и улучшена открываемость <span class="No-Break">автозаполнения в IDE.</span></li> <li>Поддержка как Options, так и <span class="No-Break">Composition API.</span></li> <li>Более эффективное внутреннее использование новых <span class="No-Break">реактивных моделей Vue.</span></li> <li>Поддержка <span class="No-Break">инструментов разработчика.</span></li> <li>Архитектура плагинов для <span class="No-Break">расширения Pinia.</span></li> </ul> <p>Переход от Vuex к Pinia затрудняет одномоментное обновление проектов, которые его использовали. Однако команда Pinia опубликовала на официальном сайте хорошее руководство по миграции, которое можно найти здесь:<a href="https://pinia.vuejs.org/cookbook/migration-vuex.html"> https://pinia.vuejs.org/cookbook/migration-vuex.html</a>. Для полного ознакомления со всеми возможностями, доступными в Pinia, я рекомендую прочитать официальную документацию <span class="No-Break">по адресу </span><a href="https://pinia.vuejs.org/"><span class="No-Break">https://pinia.vuejs.org</span></a><span class="No-Break">.</span></p> <p>С помощью Pinia мы рассмотрели наиболее распространенные и актуальные паттерны для управления потоком данных между компонентами (и сервисами!), но это не единственные доступные нам. Далее мы рассмотрим хранилища, предоставляемые по умолчанию в современных веб-браузерах, и то, как <span class="No-Break">использовать их.</span></p> <h1>Хранилища данных браузера - сессионные, локальные и IndexedDB</h1> <p>Браузеры предоставляют и другие возможности для локального хранения данных, которые могут быть прочитаны не только любым другим компонентом, но и любым скриптом, выполняющимся на той же странице. Мы будем говорить не о cookies, а о новых методах, предоставляемых в качестве хранилищ ключевых значений: <strong class="source-inline">SessionStore</strong> и <strong class="source-inline">LocalStore</strong>. Но это не единственные варианты, поскольку браузеры также предоставляют базу данных <strong class="source-inline">IndexedDB</strong>, которая предлагает гораздо больше места для хранения данных и может быть доступна также за пределами окна нашего приложения в другом потоке. Более подробно мы рассмотрим это в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_08.xhtml#_idTextAnchor186"><span class="No-Break"><em class="italic">главе 8</em></span></a>, <em class="italic">Multithreading with Web Workers</em>, а здесь мы сосредоточимся на понимании основной концепции и ограничений <span class="No-Break">каждого из них.</span></span></p> <p><strong class="source-inline">SessionStorage</strong> - это объект, доступный только для чтения, создаваемый для каждого начала страницы. В нем хранятся только строковые данные, доступ к которым можно получить с помощью простого интерфейса. Эти данные существуют только в течение времени работы <em class="italic">вкладки браузера</em> и сохраняются при обновлении. Ярким примером такого использования является сохранение данных формы. Объект привязывается к объекту <strong class="source-inline">window</strong> (<strong class="source-inline">window.sessionStorage</strong>) и может быть доступен любому скрипту на <span class="No-Break">странице.</span></span></p> <p><strong class="source-inline">LocalStorage</strong> по возможностям и хранению данных похож на <strong class="source-inline">SessionStorage</strong>. Оно имеет тот же интерфейс и ограничено тем же происхождением страницы. Основное отличие заключается в том, что она сохраняется за пределами жизни страницы и является общей для всех открытых страниц одного происхождения. Веб-сайты и приложения могут использовать его для хранения данных и их извлечения в течение нескольких сеансов в <span class="No-Break">одном и том же браузере.</span></p> <p><strong class="source-inline">SessionStorage</strong> и <strong class="source-inline">LocalStorage</strong> имеют <span class="No-Break">одинаковый интерфейс:</span></p> <ul> <li><strong class="source-inline">.setItem(item_name, item_data)</strong>: Здесь <strong class="source-inline">item_name</strong> - это строка, которая однозначно идентифицирует <strong class="source-inline">item_data</strong>, которая также является <span class="No-Break">строкой</span></li> <li><strong class="source-inline">.getItem(item_name)</strong>: Получает строковые данные, хранящиеся под именем <strong class="source-inline">item-_name</strong>, или null, если <span class="No-Break">не найдено</span></li> <li><strong class="source-inline">.removeItem(item_name)</strong>: Удаляет данные по <strong class="source-inline">имени_элемента</strong> из <span class="No-Break">магазина</span></li> <li><strong class="source-inline">.clear()</strong>: Удаляет все данные из <span class="No-Break">хранилища</span></li> </ul> <p>Вышеперечисленные методы представляют собой совокупность конечных точек API для обоих хранилищ. Все достаточно просто - мы можем сериализовать данные, чтобы записать их в эти хранилища. Например, для хранения JSON-объекта мы используем следующее (ссылку на объект <strong class="source-inline">window</strong> можно опустить, так как он считается <span class="No-Break">глобальным объектом):</span></p> <div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code"> localStorage.setItem("MyData", JSON.stringify({...});</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div> <p>А затем, чтобы получить его, мы используем <span class="No-Break">следующее:</span></p> <div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code"> let data=localStorage.getItem("MyData") if(data){ &nbsp;&nbsp;&nbsp;&nbsp;data=JSON.parse(data); }</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div> <p>У обоих хранилищ есть некоторые ограничения и <span class="No-Break">несколько предостережений:</span></span></p> <ul> <li>В браузерах не существует стандартного ограничения на количество символов, которое может содержать каждое хранилище. Строки хранятся в формате UTF-16, поэтому каждый символ может занимать от 2 байт и более (см. <a href="https://en.wikipedia.org/wiki/UTF-16">https://en.wikipedia.org/wiki/UTF-16</a>), что затрудняет расчеты. В спецификациях рекомендуется не менее 5 МБ для <span class="No-Break">каждого хранилища.</span></li> <li>Когда в этих хранилищах заканчивается место, некоторые браузеры аварийно завершают работу страницы, другие запрашивают у пользователя согласие на расширение <span class="No-Break">хранилища.</span></li> <li>Доступ к хранению и получению данных осуществляется последовательно, что может блокировать процесс рендеринга и сделать страницу/приложение неотзывчивым... Но это происходит только при <span class="No-Break">длительных операциях.</span></li> <li>Для <strong class="source-inline">sessionStorage</strong> дублирование вкладок приведет и к дублированию хранилища. Вместо этого для <strong class="source-inline">localStorage</strong> обе вкладки будут обращаться к <span class="No-Break">одной и той же информации.</span></li> <li>Ни localStorage, ни sessionStorage не являются реактивными и не предоставляют слушателей для отслеживания изменения <span class="No-Break">значения.</span></li> </ul> <p>Вышеперечисленные ограничения ни в коем случае не являются угрозой или предложением не использовать их. Наоборот, это границы и пределы их использования, поскольку все данные хранятся локально в браузере пользователя и ничего не отсылается обратно на сервер (как это делают <span class="No-Break">cookies).</span></p> <p>В отличие от этих объектов веб-хранилища, <strong class="source-inline">IndexedDB</strong> представляет собой совершенно другую систему. Это полноценная реализация транзакционной базы данных, которая хранит объекты JavaScript под уникальным ключом. Мы можем открывать несколько баз данных, создавать соединения с ними и определять схемы, причем все операции выполняются асинхронно, так что блокировка приложения исключена. Также расширено ограничение на размер базы данных: мягкое ограничение составляет 50 МБ. Если база данных вырастает больше этого значения, пользователю предлагается дать согласие на ее расширение, и место предоставляется. Теоретически, в зависимости от реализации в каждом браузере, она может занимать столько места, сколько доступно. На практике каждый браузер по-своему договаривается о доступном пространстве с локальной операционной системой, поэтому нельзя указать жесткое число, которое будет справедливо в <span class="No-Break">каждом случае.</span></p> <p class="callout-heading">Ключевой момент</p> <p class="callout">В движке Chrome предусмотрен флаг, позволяющий строить движок без ограничений для <strong class="source-inline">IndexedDB</strong>, за исключением доступного дискового пространства. Этот флаг также может быть активирован в гибридных фреймворках, таких как NW.js, или при сборке браузера <span class="No-Break">из исходного кода.</span></p> <p>Существует серьезная проблема с <strong class="source-inline">IndexedDB</strong>, которая заключается в том, что ее API является сложным и громоздким, поэтому очень редко приложения обращаются к ней напрямую. Вместо этого, поскольку <strong class="source-inline">IndexedDB</strong> настолько гибкая и быстрая, существует достаточно большое количество библиотек, которые создают собственную реализацию базы данных на ее основе или обеспечивают более простой интерфейс (например, с использованием паттерна Façade). Список этих библиотек и фреймворков можно найти в документации <strong class="bold">Mozilla Developer Network</strong> (https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API#see_also). В наших примерах реализации <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_08.xhtml#_idTextAnchor186"><span class="No-Break"><em class="italic">главы 8</em></span></a>, <em class="italic">Multithreading with Web Workers</em>, мы будем использовать одну из этих библиотек. Для целей этой главы просто помните, что каждый браузер предоставляет вам мощную базу данных для вашего приложения, и вы можете обращаться к ней с помощью различных паттернов <span class="No-Break">и подходов.</span></span></p> <h1>Экспериментируем с паттернами reactivity и Proxies</h1> <p>Настало время применить на практике то, что мы узнали в этой главе, в свете паттернов, которые мы рассматривали в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_02.xhtml#_idTextAnchor040"><span class="No-Break"><em class="italic">Глава 2</em></span></a>, <em class="italic">Принципы и паттерны проектирования программного обеспечения</em>, с помощью небольшого экспериментального проекта. Мы хотим создать возможность заставить данные <strong class="source-inline">sessionStorage</strong> вести себя как реактивный центральный менеджер состояний, чтобы мы могли использовать его в наших компонентах. Возможными вариантами использования этого подхода могут быть сохранение введенных пользователем данных при обновлении, оповещение компонентов об изменении данных и <span class="No-Break">так далее.</span></p> <p>Поскольку <strong class="source-inline">SessionStorage</strong> не предоставляет API, к которому мы могли бы обращаться, наш подход будет заключаться в создании обработчика Proxy с использованием шаблона Decorator, чтобы сопоставить и синхронизировать значения в хранилище с внутренним и частным реактивным свойством. Мы обернем его в <em class="italic">синглтон</em> и используем подход <em class="italic">Central State </em>manager для его совместного использования в нашем приложении. Начнем с создания нашего <span class="No-Break">основного сервиса:</span></p> <p class="SC---Heading" lang="en-US" xml:lang="en-US">/services/sessionStorage.js</p> <div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code"> import { reactive } from 'vue';  let <strong class="bold">handler </strong>= {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1 <strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;props: reactive({})</strong>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2 <strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;get</strong>(target, prop, receiver) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let value = target[prop] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (value instanceof Function) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (...args) =&gt; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return target[prop](....args) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value = target.getItem(prop) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (value) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.props[prop] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, <strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;set</strong>(target, prop, value) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target.setItem(prop, value) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.props[prop] = value &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}  } const Decorator= new Proxy(window.sessionStorage,&nbsp;handler);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//5 function <strong class="bold">useSessionStorage</strong>(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//6 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Decorator; } export { useSessionStorage }</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div> <p>В этом модуле <strong class="source-inline">service</strong> мы будем использовать собственную JavaScript-реализацию объекта <strong class="source-inline">Proxy</strong> для перехвата конкретных обращений к API объекта <strong class="source-inline">window.sessionStorage</strong>. Использование объектов Proxy является достаточно сложным в JavaScript, поэтому я рекомендую ознакомиться с документацией на MDN здесь: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a>. Начнем с импорта конструктора <strong class="source-inline">reactive()</strong> из Vue, а затем создадим простой объект с именем <strong class="source-inline">handler</strong> (строка <strong class="source-inline">//1</strong>), который будет выступать в роли нашего прокси/декоратора. Этот объект будет размещен для перехвата обращений к исходному <strong class="source-inline">sessionStorage</strong>. Внутри него мы объявляем свойство <strong class="source-inline">prop</strong> как реактивное (строка <strong class="source-inline">//2)</strong>), инициализируя его пустым объектом. Этот объект будет синхронизирован с хранилищем. Затем мы создаем две ловушки (или перехватчики): одну для операций получения или чтения (строка <strong class="source-inline">//3</strong>), другую для операций установки или записи (<span class="No-Break">строка </span><span class="No-Break"><strong class="source-inline">//4</strong></span><span class="No-Break">).</span></p> <p>Функция <strong class="source-inline">get()</strong> принимает три аргумента, из которых мы будем использовать только два. Target ссылается на <strong class="source-inline">sessionStorage</strong>, а <strong class="source-inline">prop</strong> - это имя запрашиваемого метода или атрибута. Поскольку <strong class="source-inline">prop</strong> может быть любым из них, мы проверяем, является ли это функцией, с помощью оператора <strong class="source-inline">if</strong>, и если да, то возвращаем функцию, которая принимает все аргументы и возвращает исходный вызов функции с ними. Если это не функция, то мы получаем элемент из магазина, проверяем, является ли он частью нашего внутреннего реактивного свойства, и, наконец, возвращаем его значение.  Это гарантирует, что наш внутренний объект <strong class="source-inline">props</strong> синхронизирован со значениями, созданными до того, как декоратор <span class="No-Break">был реализован.</span></p> <p>Функция <strong class="source-inline">set()</strong> проще, поскольку мы просто берем переданное значение и храним его в обоих местах: в нашем внутреннем props и <span class="No-Break">в магазине.</span></p> <p> Когда наш обработчик готов, в строке <strong class="source-inline">//5</strong>, мы создаем прокси-объект <strong class="source-inline">Decorator</strong> с помощью собственного конструктора JavaScript и предоставляем функцию <strong class="source-inline">useSessionStorage()</strong> в строке <strong class="source-inline">//6</strong>, чтобы мы могли экспортировать его как <span class="No-Break">синглтон.</span></span></p> <p>Создав наш декоратор, теперь мы можем использовать его в наших компонентах, используя тот же подход, который является стандартным в <span class="No-Break">Vue 3:</span></p> <p class="SC---Heading" lang="en-US" xml:lang="en-US">/session_storage/ChildSession.vue</p> <div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code"> &lt;script setup&gt; &nbsp;&nbsp;&nbsp;&nbsp;import {<strong class="bold">useSessionStorage</strong>} from "../../services/SessionStorage" &nbsp;&nbsp;&nbsp;&nbsp;const <strong class="bold">$sessionStorage </strong>= <strong class="bold">useSessionStorage()</strong> &lt;/script&gt; &lt;template&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;strong&gt;Child Component&lt;/strong&gt; &nbsp;&nbsp;&nbsp;&nbsp;Counter: {{ <strong class="bold">$sessionStorage.counter </strong>}} &lt;/template&gt;</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div> <p>Заметьте, что теперь мы можем использовать этот объект как хранилище Pinia или простой реактивный объект, и значение <strong class="source-inline">sessionStorage</strong> всегда будет синхронизировано и сохранится, даже если мы обновим страницу. Для просмотра полного примера ознакомьтесь с реализацией примера кода в репозитории GitHub. При его запуске вы увидите секцию, подобную <span class="No-Break">этой:</span></p> <div> <div id="_idContainer054" class="IMG---Figure"> <img src="Chapter%20777%20Data%20Flow%20Management%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_7.06_B18602.jpg" alt="Figure 7.6 - Пример нашего реактивного объекта $sessionStorage" width="650" height="152"> </div> </div> <p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 7.6 - Пример нашего реактивного объекта $sessionStorage</p> <p>В этом примере мы также реализовали родительский компонент с элементом ввода. При изменении значения оно автоматически синхронизируется и отражается в дочернем компоненте, а также в <strong class="source-inline">sessionStorage</strong>. Если открыть инструменты разработчика браузера и перейти в раздел <strong class="bold">Web Storage</strong>, то можно увидеть это отражение. Вот скриншот того, как это выглядит в Chrome на системе <span class="No-Break">Ubuntu:</span></span></p> <div> <div id="_idContainer055" class="IMG---Figure"> <img src="Chapter%20777%20Data%20Flow%20Management%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_7.07_B18602.jpg" alt="Рисунок 7.7 - Хранилище сеансов, показывающее элемент из примера" width="850" height="135"> </div> </div> <p class="IMG---Caption" lang="en-US" xml:lang="en-US">Рисунок 7.7 - Сессионное хранилище, показывающее элемент из примера</p> <p>Так же, как мы реализовали этот паттерн для сессионного хранилища, мы можем с небольшими изменениями применить его и к <span class="No-Break">локальному хранилищу.</span></p> <h1>Summary</h1> <p>В этой главе мы подробно рассмотрели различные подходы и методы управления потоком данных между нашими компонентами, сервисами и постоянными хранилищами, предоставляемыми современными браузерами. Мы также уделили время интеграции наших знаний, экспериментируя с хранением сессий и паттерном Decorator для создания реактивного/постоянного центрального состояния. Мы уделили время разграничению подходов и посмотрели код для реализации каждого метода. Все эти новые навыки ежедневно используются при разработке приложений Vue <span class="No-Break">3.</span></span></p> <p>В следующей главе мы рассмотрим повышение производительности нашего приложения с помощью современных инструментов JavaScript: <span class="No-Break">web workers.</span></p> <h1>Вопросы для обзора</h1> <p> Используйте эти вопросы для обзора того, что вы узнали в <span class="No-Break">этой главе:</span></p> <ul> <li>Какие методы доступны нам для обмена данными между <span class="No-Break">родственными компонентами?</span></li> <li>Что такое шина сообщений/событий, и когда она <span class="No-Break">наиболее полезна?</span></li> <li>Что такое централизованное управление состоянием, и как его можно <span class="No-Break">реализовать?</span></li> <li>В чем разница между сессией и <span class="No-Break">локальным хранилищем?</span></li> <li>Как мы можем увидеть, какая информация хранится в сессии или <span class="No-Break">локальном хранилище?</span></li> </ul>