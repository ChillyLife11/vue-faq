 			<h1>Data Flow Management</h1>  			<p>In previous chapters, we have focused on understanding the Vue 3  framework and providing a context to create web applications. In this  chapter, we will focus on the way our components communicate with each  other and share information to make our application happen. We have  touched on this topic briefly previously, but now we will dive deep into  some patterns by implementing them alongside each other. Applying an  appropriate information workflow is an important skill that can make or  break an application. In particular, we will see the following  approaches and <span class="No-Break">code examples:</span></p>  			<ul>  				<li><span class="No-Break">Parent-child-sibling communication</span></li>  				<li>Implementing a message bus using the <strong class="bold">Singleton </strong>and <span class="No-Break"><strong class="bold">Observer </strong></span><span class="No-Break">patterns</span></li>  				<li>Implementing a basic reactive state with <span class="No-Break">composable components</span></li>  				<li>Implementing a centralized data repository with the powerful Pinia <span class="No-Break">reactive store</span></li>  				<li>Reviewing browser-provided alternatives to share and <span class="No-Break">store information</span></li>  				<li>Experimenting with reactivity, composables, and proxy patterns <span class="No-Break">in action</span></li>  			</ul>  			<p>As we have done previously, we will be building one concept at a  time, incrementing in complexity. By the end of this chapter, you will  have seen clear examples of implementation so that you can decide when  to apply each one based on the needs of your application. Some of these  are more suitable for small applications, and others for large, complex  ones. You will be better prepared to control the workflow of information  for <span class="No-Break">your application.</span></p>  			<h1>Technical requirements</h1>  			<p>This chapter will approach concepts and apply patterns to control  the communication and flow of information between components. You should  be able to follow through with the code presented in this text, but for  a better understanding and context experience, you would benefit from  inspecting the full application code for this chapter, available in the  repository for this <span class="No-Break">book: </span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter07"><span class="No-Break">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter07</span></a><span class="No-Break">.</span></p>  			<p>If you are starting a new project, just follow the instructions for scaffolding one, as seen in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_03.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Setting Up a </em><span class="No-Break"><em class="italic">Working Project</em></span><span class="No-Break">.</span></p>  			<p>Check out the following video to see the Code in <span class="No-Break">Action: </span><a href="https://packt.link/ZKTBJ"><span class="No-Break">https://packt.link/ZKTBJ</span></a></p>  			<h1>Components’ basic communication</h1>  			<p>We have seen previously that a parent component and its children have a rather simple and straightforward way to communicate. Parents pass data as <strong class="source-inline">props</strong> to their children, and these raise events (<strong class="source-inline">emits</strong>) to capture the attention of the parent. Much like the comparability of parameters and arguments in functions, <strong class="source-inline">props</strong>  receive simple data by copy, and complex types (objects, arrays, and so  on) by reference. We could pass, then, a plain object with member  functions from the parent to the child, and have the child run the  functions to access the parent’s data. Even though this “works”, it is  sort of a dark pattern or anti-pattern, as it hides the relationship and  makes it difficult to understand the data flow. The proper way to pass  data upward in the component tree is through events (<strong class="source-inline">emits</strong>).  Having said this, we must point out that child components are  “ignorant” of each other, meaning that they do not have a direct way to  communicate among themselves. We could pass a reactive variable and have  each component involved access it, and this is certainly a working  alternative, if not a clean one. In some cases, this would provide a  simple solution, but again, it can lead to hidden <span class="No-Break">side effects.</span></p>  			<p>To manage in a clean way the workflow of data, we have several  alternatives that follow good practices and design patterns. As a  general rule and principle, the component that declares the variable is  the owner of it, and it should be the one that manipulates it. With this  in mind, in the most basic communication, the information needs to be  maintained and manipulated by the parent component and shared among the  children. We can leverage Vue’s reactive system to spread the  information. The key here is that only the parent component will  manipulate it. Let’s see how this works in practice with an example,  implementing a small trivial application, as shown in <span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>  			<div>  				<div id="_idContainer049" class="IMG---Figure">  					<img src="Chapter%20777%20Data%20Flow%20Management%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_7.01_B18602.jpg" alt="Figure 7.1 – Direct basic communication and reactivity" width="536" height="155">  				</div>  			</div>  			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Direct basic communication and reactivity</p>  			<p>In this application, the parent component  has three direct children and shares with them a reactive counter. All  the components display a label with the value of the counter and have a  button to trigger an increment... but only the father component performs  the actual manipulation of the data. Vue handles the reactivity,  meaning that when the parent modifies the value, the child components  also receive them. Simple enough—let’s see the important parts of how  this <span class="No-Break">is implemented:</span></p>  			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/basic/ParentBasic.vue</p>  			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code">  &lt;script setup&gt;  import {ref} from "vue"  import ChildComponent from "./Child.vue"  const <strong class="bold">_counter</strong> = ref(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//1</strong>  function <strong class="bold">incrementCounter()</strong> {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//2</strong>  &nbsp;&nbsp;&nbsp;_counter.value++;  }  &lt;/script&gt;  &lt;template&gt;  &lt;div&gt;  &nbsp;&nbsp;&nbsp;&lt;strong&gt;Counter &lt;/strong&gt;  &nbsp;&nbsp;&nbsp;&lt;span&gt;{{ _counter }}&lt;/span&gt;  &nbsp;&nbsp;&nbsp;&lt;button <strong class="bold">@click="incrementCounter()"</strong>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//3</strong>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increment  &nbsp;&nbsp;&nbsp;&lt;/button&gt;  &lt;/div&gt;  &lt;section&gt;  &lt;ChildComponent title="Child component 1"  &nbsp;&nbsp;<strong class="bold">:counter="_counter" @increment="incrementCounter()"</strong>&gt;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//4</strong>  &lt;/ChildComponent&gt;  &lt;ChildComponent title="Child component 2"  &nbsp;&nbsp;<strong class="bold">:counter="_counter" @increment="incrementCounter()"</strong>&gt;  &lt;/ChildComponent&gt;  &lt;ChildComponent title="Child component 3"  &nbsp;&nbsp;<strong class="bold">:counter="_counter"</strong>  <strong class="bold">&nbsp;&nbsp;@increment="incrementCounter()"</strong>&gt;&lt;/ChildComponent&gt;  &lt;/section&gt;  &lt;/template&gt;</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div>  			<p>In this component, we declare a <strong class="source-inline">_counter</strong> reactive variable (line <strong class="source-inline">//1</strong>) and an <strong class="source-inline">incrementCounter()</strong> function to manipulate its value (line <strong class="source-inline">//2</strong>). We trigger this function in the parent button, on the click event, as seen in line <strong class="source-inline">//3</strong>. Now, to see this pattern implemented, we just pass our reactive <strong class="source-inline">_counter</strong> variable as a prop to each child component, and we link our <strong class="source-inline">incrementCounter()</strong> function to each child’s increment event (line <strong class="source-inline">//4</strong>). Simple enough—let’s see how each child implements <span class="No-Break">its part:</span></p>  			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/basic/Child.vue</p>  			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code">  &lt;script setup&gt;  const  <strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;$props=defineProps(['counter', 'title'])</strong>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1  <strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;$emit=defineEmits(['increment'])</strong>  function incrementCounter(){$emit("increment")}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2  &lt;/script&gt;  &lt;template&gt;  &lt;h3&gt;{{$props.title}}&lt;/h3&gt;  &lt;span class="badge"&gt;<strong class="bold">{{$props.counter}}</strong>&lt;/span&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3  &lt;button<strong class="bold"> @click="incrementCounter()"</strong>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//4  &nbsp;&nbsp;&nbsp;&nbsp;Increment  &lt;/button&gt;  &lt;/template&gt;</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div>  			<p>Our child implementation is simple as well. We start by defining the props to receive the counter variable in line <strong class="source-inline">//1</strong>, and also our <strong class="source-inline">increment</strong> custom event so that we can notify the parent. In order to do that, we create a function in line <strong class="source-inline">//2</strong>. In our template, we display our prop in line <strong class="source-inline">//3</strong> and trigger our increment function in line <strong class="source-inline">//4</strong>.  Notice that our child component does not modify the counter. That is  the responsibility of the father component, so we respect <span class="No-Break">the pattern.</span></p>  			<p>This pattern is one that we will use  quite often, but it does have some limitations. For example, what  happens when the data needs to reach a parent, sibling, or grandchild?  Do we pass data up and down the tree, even though components don’t use  it? We could, but again, that is messy, verbose, and not the best way.  We have better tools <span class="No-Break">for that.</span></p>  			<p>In <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_04.xhtml#_idTextAnchor102"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">User Interface Composition with Components</em>, we saw that a parent can pass data and functionality to any of their children down the tree, by using <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) with <strong class="source-inline">provide</strong> and <strong class="source-inline">inject</strong>.  Since the example presented there was quite comprehensive, we will not  repeat it here. I encourage you to review how the provision was created  and injected. Instead of repeating ourselves, let’s move ahead with the  next item in our agenda to share information anywhere in the component tree: implement a <strong class="bold">message bus</strong> (also called an <span class="No-Break"><strong class="bold">event bus</strong></span><span class="No-Break">).</span></p>  			<h1>Implementing an event bus with the Singleton and Observer patterns</h1>  			<p>A message bus is an implementation of the <em class="italic">Observer pattern</em> that we saw in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_02.xhtml#_idTextAnchor040"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Software Design Principles and Patterns</em>. As a short refreshment of the main concept, we seek to create an object  or structure that receives and emits events that our components can  subscribe and react to. This pattern runs independently of the component  tree structure, so any <em class="italic">component and service</em> can make use of it. Visually, we can represent the resulting relationship <span class="No-Break">as follows:</span></p>  			<div>  				<div id="_idContainer050" class="IMG---Figure">  					<img src="Chapter%20777%20Data%20Flow%20Management%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_7.02_B18602.jpg" alt="Figure 7.2 – A simplified view of a message bus relationship with components" width="590" height="147">  				</div>  			</div>  			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – A simplified view of a message bus relationship with components</p>  			<p>From the preceding diagram, we can immediately see that each  component is treated equally by the message bus. Each component  subscribes one or more of its methods to a specific event, and at the  same time has the same possibility to publish an event. This makes it  very flexible, as events can also <span class="No-Break">transport data.</span></p>  			<p>Let’s bring down to code these concepts with an implementation  example. We start by creating a service, using the Singleton pattern,  that provides us with a message bus. In our case, we will just wrap the <strong class="source-inline">mitt</strong> package, which gives us this functionality (<span class="No-Break">see </span><span class="No-Break">https://github.com/developit/mitt#usage</span><span class="No-Break">).</span></p>  			<p>The <strong class="source-inline">mitt</strong> package can be installed in our application with the following command in <span class="No-Break">the terminal:</span></p>  			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="console">  $ npm install mitt</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div>  			<p>Our service then looks <span class="No-Break">like this:</span></p>  			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/services/MessageBus.js</p>  			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code">  import mitt from "mitt"  const messageBus = mitt()  export default messageBus</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div>  			<p>This will give us a singleton for an event emitter and dispatcher, meaning our message bus. In our example, we will dispatch text messages through it, and each receiving component will display it. Our components will then look something <span class="No-Break">like this:</span></p>  			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/bus/Child.vue</p>  			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code">  &lt;script setup&gt;  import <strong class="bold">messageBus </strong>from '../services/MessageBus';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//1</strong>  import {ref, onMounted, onBeforeUnmount} from 'vue';  const  &nbsp;&nbsp;&nbsp;$props=defineProps(['title']),  &nbsp;&nbsp;&nbsp;<strong class="bold">message=ref("")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//2</strong>  &nbsp;&nbsp;&nbsp;&nbsp;onMounted(()=&gt;{  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">messageBus.on(</strong>"message", showMessage)})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//3</strong>  &nbsp;&nbsp;&nbsp;&nbsp;onBeforeUnmount(()=&gt;{  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">messageBus.off(</strong>"message",showMessage)})  &nbsp;&nbsp;&nbsp;&nbsp;function <strong class="bold">showMessage</strong>(value){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//4</strong>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message.value=value;}  &nbsp;&nbsp;&nbsp;&nbsp;function <strong class="bold">sendMessage</strong>(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//5</strong>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;messageBus.emit("message",`Sent by ${$props.title}`)}  &lt;/script&gt;  &lt;template&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&lt;h4&gt;{{$props.title}}&lt;/h4&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&lt;strong&gt;Received: &lt;/strong&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;{{message}}&lt;/div&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&lt;button <strong class="bold">@click="sendMessage()"</strong>&gt;Send message&lt;/button&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//6</strong>  &lt;/template&gt;</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div>  			<p>In this example, we start in line <strong class="source-inline">//1</strong> by importing our <strong class="source-inline">messageBus</strong> object (check the right path in your implementation) and declare a <strong class="source-inline">message</strong> reactive variable initialized to an empty string. Notice how we also import and use the <strong class="source-inline">onMounted()</strong> and <strong class="source-inline">onBeforeUnmount()</strong> methods from the component’s life cycle to subscribe and unsubscribe to the <strong class="source-inline">message</strong> event starting in line <strong class="source-inline">//3</strong>. The function that we register is in line <strong class="source-inline">//4</strong>, and it receives from the event a value that we pass to our internal variable to display in the template. We also need a function to publish the event to notify others, and that can be found in line <strong class="source-inline">//5</strong>. In this case, we publish the title of the component. This function is triggered by a button, as shown in <span class="No-Break">line </span><span class="No-Break"><strong class="source-inline">//6</strong></span><span class="No-Break">.</span></p>  			<p>If you run the application example with some additional minimal styling, this code will result in something <span class="No-Break">like this:</span></p>  			<div>  				<div id="_idContainer051" class="IMG---Figure">  					<img src="Chapter%20777%20Data%20Flow%20Management%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_7.03_B18602.jpg" alt="Figure 7.3 – A simple implementation of data sharing through the Observer pattern" width="941" height="390">  				</div>  			</div>  			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – A simple implementation of data sharing through the Observer pattern</p>  			<p>This approach to handling the workflow of data is quite effective  in what it does, but also has limitations. Events are a good way to  notify multiple components simultaneously to trigger actions,  independently of their place in the organization tree. When an  application has multiple sub-systems that need to react to an  application state change, this is a good pattern to apply. However, when  dealing mainly with application data, this pattern has an important  drawback: each component keeps an internal copy of the information. This  makes the handling of memory quite inefficient, as the propagation of  data means copying into different parts of our application. There are  cases when this is necessary or desired, but certainly not for every  case. If we have 50, 100, or 1,000 components subscribed to the same  event, will all of them have the same copy of the data? If each  component needs to handle and possibly modify the data independently of  the others, this works fine... but if we want to make better use of Vue’s reactivity and improve our memory handling, we need to use a different approach. This is what we will see next with a basic reactive <span class="No-Break">application state.</span></p>  			<h1>Implementing a basic reactive state</h1>  			<p>As mentioned before, a drawback of  using a message bus to share data is the multiplicity of copies of the  same data, including the overhead for the handling of the events.  Instead, we can leverage Vue’s reactivity engine and, in particular, the  <strong class="source-inline">reactive()</strong> helper constructor to  create a single entity to hold our application state. Just like before,  we can wrap this reactive object in a Singleton pattern to share it  among components and plain JavaScript functions, objects, and classes.  It's worth mentioning that this is one of the great advantages of Vue 3  and the new <span class="No-Break">Composition API.</span></p>  			<p>From the example code, we will end with a basic example <span class="No-Break">like this:</span></p>  			<div>  				<div id="_idContainer052" class="IMG---Figure">  					<img src="Chapter%20777%20Data%20Flow%20Management%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_7.04_B18602.jpg" alt="Figure 7.4 – A shared reactive object for state management" width="514" height="187">  				</div>  			</div>  			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – A shared reactive object for state management</p>  			<p>As you can see in the previous  screenshot, the state in this case is shared (or accessed) by all the  components of this example. Any of the child components can modify any  of its values, and the change is reflected immediately across the  application. In contrast with the previous examples, the implementation  of this pattern is both simple and straightforward. Let’s dive into it  by first creating a service with our <span class="No-Break">reactive state:</span></p>  			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/service/SimpleState.js</p>  			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code">  import {reactive} from "vue"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1  const _state=reactive({counter: 0})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2  function useState(){return _state;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3  export default useState;</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div>  			<p>If this code seems simple, it is because indeed it is. We create a JavaScript file and import the <strong class="source-inline">reactive</strong> constructor from Vue (line <strong class="source-inline">//1</strong>). Then, we declare a reactive constant with an initial object (line <strong class="source-inline">//2</strong>). This will be the application state that we return through a <strong class="source-inline">useState()</strong> function, named following the model of composable components (line <strong class="source-inline">//3</strong>). This function is our <span class="No-Break">module exports.</span></p>  			<p>Making use of this centralized state is also very simple, as we can <span class="No-Break">see here:</span></p>  			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/simple/ChildSimple.vue</p>  			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code">  &lt;script setup&gt;  &nbsp;&nbsp;&nbsp;&nbsp;import <strong class="bold">useState </strong>from "../../services/SimpleState"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1  &nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">const $state=useState()</strong>  &lt;/script&gt;  &lt;template&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&lt;strong&gt;State: &lt;/strong&gt;&lt;br&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&lt;pre&gt;<strong class="bold">{{$state}}</strong>&lt;/pre&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2  &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&lt;button <strong class="bold">@click="$state.counter++"</strong>&gt;Increment&lt;/button&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3  &nbsp;&nbsp;&nbsp;&nbsp;&lt;button @click="$state.counter--"&gt;Decrement&lt;/button&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;  &lt;/template&gt;</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div>  			<p>We start our component by importing the <strong class="source-inline">useState</strong> factory function, and we declare a reactive constant using it (line <strong class="source-inline">//1</strong>). We use this reactive variable in our template just like any other (line <strong class="source-inline">//2</strong>),  and in the same way, we can access directly the member fields of the  object to modify them as with any other object, as you can see in line <strong class="source-inline">//3</strong>. Having done this, as one would expect, once a component modifies any value, the change gets propagated across <span class="No-Break">the application.</span></p>  			<p>This simple approach is very useful and fit for small to even medium-sized applications. It has many benefits, such as <span class="No-Break">the following:</span></p>  			<ul>  				<li>It is easy to implement <span class="No-Break">and understand.</span></li>  				<li>It leverages Vue’s <span class="No-Break">reactivity system.</span></li>  				<li>It is flexible, as we can add new reactive members <span class="No-Break">after initialization.</span></li>  				<li>It establishes a single source of truth meaning that our state  is the centralized repository of the application data. There's no need  to keep internal or private <span class="No-Break">variables synchronized.</span></li>  			</ul>  			<p>If you consider the options we have seen until now, this is a giant leap forward. However, there are some situations when these <span class="No-Break">falls short:</span></p>  			<ul>  				<li>What happens when a function modifies its value in an asynchronous manner if other components made changes before it <span class="No-Break">was resolved?</span></li>  				<li>This approach does not allow us to handle computed data that needs to be implemented in <span class="No-Break">each component</span></li>  				<li>Debugging could be hard as there is no specific support for <span class="No-Break">developer tools</span></li>  			</ul>  			<p>As mentioned, this approach is  suitable for simple needs. For a more robust approach, we will dig into  the official central state management solution by the Vue <span class="No-Break">project: </span><span class="No-Break"><strong class="bold">Pinia</strong></span><span class="No-Break">.</span></p>  			<h1>Implementing a powerful reactive store with Pinia</h1>  			<p>Central state management is not a concept private only to Vue, and the same pattern can be found in other libraries and frameworks. Just as in our basic reactive example, <strong class="bold">Pinia</strong> is a central state management tool that provides  us with a single source of truth, meaning that a change in one of its  values will propagate reactively to the entire application wherever is  used. This state is shared among components in the application and gives  us access to the full range of reactive tools Vue provides through a  well-defined interface. It is easier to understand Pinia if first we  build an example to show the results of using it. Running the code  example will give us something <span class="No-Break">like this:</span></p>  			<div>  				<div id="_idContainer053" class="IMG---Figure">  					<img src="Chapter%20777%20Data%20Flow%20Management%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_7.05_B18602.jpg" alt="Figure 7.5 – Central state management with Pinia" width="646" height="275">  				</div>  			</div>  			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Central state management with Pinia</p>  			<p>In this example, we build a store that not only exposes a reactive  state but also implements computed values. As an officially supported  project, Pinia also exposes implementations of the Options and  Composition APIs. To use Pinia, we need to first include it in our  project with the following command in the project’s <span class="No-Break">root directory:</span></p>  			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code">  $ npm install pinia</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div>  			<p>After the installation, we should create a store and then attach  it to our application so that it can be used by all the components. A  store is like our reactive singleton from the previous section, meaning  an object that will have reactive fields to be shared in our  application, but also the related business logic. So, each store will have the following items: <strong class="source-inline">data</strong>, computed properties known as <strong class="source-inline">getters</strong>, and methods known as <strong class="source-inline">actions</strong>. We define each store in its own file as a module, defining each item. Using the Options API, a store would look <span class="No-Break">like this:</span></p>  			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Options API basic store</p>  			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code">  import { <strong class="bold">defineStore </strong>} from 'pinia';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1  const <strong class="bold">useCounterStore </strong>= defineStore(<strong class="bold">'counter'</strong>, {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2  &nbsp;&nbsp;<strong class="bold">state</strong>: () =&gt; {return <strong class="bold">{count: 0, in_range: false}</strong>},&nbsp;&nbsp;&nbsp;&nbsp;//3  &nbsp;&nbsp;<strong class="bold">getters</strong>: {  &nbsp;&nbsp;&nbsp;&nbsp;doubleCount: (state) =&gt; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//4  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(state.count&gt;=0){  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return state.count *2;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}  &nbsp;&nbsp;}, inRange: (state)=&gt;return state.count&gt;=0},  &nbsp;&nbsp;<strong class="bold">actions</strong>: {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//5  &nbsp;&nbsp;&nbsp;&nbsp;increment(){this.count++},  &nbsp;&nbsp;&nbsp;&nbsp;decrement(){this.count--;}  &nbsp;&nbsp;},  })  export {<strong class="bold">useCounterStore}</strong></pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div>  			<p>In this store, we start by importing the <strong class="source-inline">defineStore</strong> constructor from the <strong class="source-inline">Pinia </strong>package (line <strong class="source-inline">//1</strong>) and use it to create a store in line <strong class="source-inline">//2</strong>. This constructor receives <span class="No-Break">two arguments:</span></p>  			<ul>  				<li>The name of the store, as a string. This has to be unique among the stores, as it is used internally as <span class="No-Break">an ID.</span></li>  				<li>An object with the store definition with the <span class="No-Break">following members:</span><ul><li><strong class="source-inline">state</strong> (line <strong class="source-inline">//3</strong>): This is a function that returns an object. Notice that we do not declare it to be reactive. Pinia will take care <span class="No-Break">of that.</span></li><li><strong class="source-inline">getters</strong> (line <strong class="source-inline">//4</strong>):  This is an object whose members will become computed properties. Each  member receives as the first argument the state of the store, as a <span class="No-Break">reactive object.</span></li><li><strong class="source-inline">actions</strong> (line <strong class="source-inline">//5</strong>):  This is, again, an object whose members are functions that can access  and modify the state but must do so by accessing it through the <span class="No-Break"><strong class="source-inline">this</strong></span><span class="No-Break"> keyword.</span></li></ul></li>  			</ul>  			<p>Using the Options API to define the store is a good way to understand the parts that make it up. However, the change of syntax between <strong class="source-inline">getters</strong> and <strong class="source-inline">actions</strong> could be confusing and lead to involuntary mistakes, as one accesses the state through an argument and the other by using the <strong class="source-inline">this</strong> reference. However, if we take a moment to look at the constructor, we can see that <strong class="source-inline">getters</strong> and <strong class="source-inline">actions</strong> are analogous to <em class="italic">computed properties and component methods</em>  (functions). With that in mind, let’s see how to rewrite this store  using the Composition API, and this is the one we will use in our <span class="No-Break">example code:</span></p>  			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/stores/counter.js</p>  			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code">  //Composition API  <strong class="bold">import {ref,computed} from 'vue'</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1  import {defineStore} from 'pinia'  const useCounterStore=defineStore('counter',<strong class="bold">()=&gt;{</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2  &nbsp;&nbsp;&nbsp;&nbsp;const  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count = ref(0),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in_range=ref(true),  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doubleCount = computed(() =&gt; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//4  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(count.value&gt;=0){  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return count.value *2;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}}),  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inRange = computed(()=&gt;return count.value&gt;=0);  &nbsp;&nbsp;&nbsp;&nbsp;function increment() {count.value++}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//5  &nbsp;&nbsp;&nbsp;&nbsp;function decrement(){count.value--;}  &nbsp;&nbsp;&nbsp;&nbsp;return {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//6  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count, doubleCount, inRange,  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;increment, decrement  &nbsp;&nbsp;&nbsp;&nbsp;}  <strong class="bold">})</strong></pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div>  			<p>Using the Composition API makes the store look more like the rest of our application, as we apply the same approach. We start by importing from Vue the constructors we need in line <strong class="source-inline">//1</strong>, as with components using the same API. This time, when we use the <strong class="source-inline">defineStore</strong>  constructor, instead of passing an object we pass a function (or arrow  function) that will return the reactive properties and methods that make  up the store. You can see this in line <strong class="source-inline">//2</strong>, and then the <strong class="source-inline">return</strong> object in line <strong class="source-inline">//6</strong>. As you can expect, inside that function we declare our reactive properties (line <strong class="source-inline">//3</strong>) and computed properties (line <strong class="source-inline">//4</strong>), and methods (line <strong class="source-inline">//5</strong>).  Reactive properties will become, well, reactive properties. Computed  properties will become our getters, and the functions will become the  actions. This far, this syntax does not have the syntactic sugar we are  used to using the <strong class="source-inline">&lt;script setup&gt;</strong> tag, but the body of the function is the same approach (state of mind) that we use <span class="No-Break">with components.</span></p>  			<p>Now that we have a store (and we could have many), before we can  actually use it, we need to implement Pinia in our application. For  that, in our <strong class="source-inline">main.js</strong> file, include the following <span class="No-Break">highlighted lines:</span></p>  			<p class="SC---Heading" lang="en-US" xml:lang="en-US">./main.js</p>  			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code">  import { createApp } from 'vue'  <strong class="bold">import { createPinia } from 'pinia'</strong>  import App from './App.vue'  const app = createApp(App)  <strong class="bold">app.use(createPinia())</strong>  app.mount('#app')</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div>  			<p>This step is necessary to enable the Pinia engine for the entire application.  What is left now is to import the store we want to use in our  components that need it. For example, if you look into the example  repository, you will find <span class="No-Break">this file:</span></p>  			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/pinia/ChildPinia.vue</p>  			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code">  &lt;script setup&gt;  import { <strong class="bold">useCounterStore </strong>} from '../../stores/counter';&nbsp;&nbsp;&nbsp;//1  const <strong class="bold">$store=useCounterStore()</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="bold">//2</strong>  &lt;/script&gt;  &lt;template&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&lt;h4&gt;Child component&lt;/h4&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&lt;code :class="{'red': !<strong class="bold">$store.in_range</strong>}"&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{$store}}  &nbsp;&nbsp;&nbsp;&nbsp;&lt;/code&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&lt;button @click="<strong class="bold">$store.increment()</strong>"&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//4  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increment&lt;/button&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&lt;button @click="$store.decrement()"  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:disabled="!$store.in_range"&gt;Decrement  &nbsp;&nbsp;&nbsp;&nbsp;&lt;/button&gt;  &lt;/template&gt;  &lt;style scoped&gt;  .red{color: red;}  &lt;/style&gt;</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div>  			<p>We import the store constructor in line <strong class="source-inline">//1</strong>, and we create our reactive object in line <strong class="source-inline">//2</strong>. To use their values or execute their methods, we use them directly as if they were regular objects using the dot (<strong class="source-inline">.</strong>) notation. Notice in line <strong class="source-inline">//3</strong> how we access the value of <strong class="source-inline">in_range</strong>, and later, in line <strong class="source-inline">//4</strong>, we execute the <strong class="source-inline">increment()</strong> function. As we would expect, any modification of the store values will be synchronized automatically across <span class="No-Break">our application.</span></p>  			<p>Unlike previous methods, Pinia stores and states are traceable and  show up on the developer tools. For applications of medium size and  above, using Pinia is almost a requirement when a central state <span class="No-Break">is necessary.</span></p>  			<p>Pinia is Vue 3’s official solution for central state  management, replacing Vuex from the Vue 2 branch. In practice, they  accomplish the same functionality, but the former has some advantages  that made the Vue team select it and sponsor it. A deep review is not a  topic for our purposes, but here is a short list of changes or advantages <span class="No-Break">of Pinia:</span></p>  			<ul>  				<li>Different approach to stores. In Pinia, each store is its own  module, and they are all dynamic. Vuex instead had one single store,  with partitions <span class="No-Break">in modules.</span></li>  				<li>The syntax and API for Pinia are simpler and less verbose <span class="No-Break">than Vuex.</span></li>  				<li>Better support for TypeScript and discoverability for the IDE’s <span class="No-Break">autocomplete features.</span></li>  				<li>Support for both Options and <span class="No-Break">Composition APIs.</span></li>  				<li>Better internal use of Vue’s new <span class="No-Break">reactive models.</span></li>  				<li>Developer <span class="No-Break">tools support.</span></li>  				<li>A plugin architecture to <span class="No-Break">extend Pinia.</span></li>  			</ul>  			<p>The change from Vuex to Pinia makes it difficult to make a  one-step replacement upgrade for projects that were using it. However,  the Pinia team has published a nice migration guide on the official website that you can find here:<a href="https://pinia.vuejs.org/cookbook/migration-vuex.html"> https://pinia.vuejs.org/cookbook/migration-vuex.html</a>. For a complete reference of all the options available with Pinia, I recommend reading the official documentation <span class="No-Break">at </span><a href="https://pinia.vuejs.org/"><span class="No-Break">https://pinia.vuejs.org</span></a><span class="No-Break">.</span></p>  			<p>With Pinia, we have seen now the most common and relevant  patterns to control the flow of data between components (and  services!), but these are not the only ones available to us. We will see  next the stores provided by default in modern web browsers, and how to <span class="No-Break">use them.</span></p>  			<h1>Browser data stores – session, local, and IndexedDB</h1>  			<p>Browsers provide other features to  store data locally, which can be read not only by any other component  but also by any script running on the same page. We will not talk about  cookies, but the new methods provided as key-value stores: <strong class="source-inline">SessionStore</strong> and <strong class="source-inline">LocalStore</strong>. But these are not the only options, as browsers also provide a database called <strong class="source-inline">IndexedDB</strong>  that offers much more storage space and can be accessed also outside  the scope of our application’s window in a different thread. We will see  how in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_08.xhtml#_idTextAnchor186"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Multithreading with Web Workers</em>, in more detail, while here, we will focus first on understanding the basic concept and limitations of <span class="No-Break">each one.</span></p>  			<p><strong class="source-inline">SessionStorage</strong> is a  read-only object created for each page origin. It stores only string  data that can be accessed and retrieved using a simple interface. This  data exists only through the duration of the <em class="italic">browser tab</em> and persists during refreshes. A clear example of this use is to persist form data. The object is attached to the <strong class="source-inline">window</strong> object (<strong class="source-inline">window.sessionStorage</strong>) and can be accessed by any script on <span class="No-Break">the page.</span></p>  			<p><strong class="source-inline">LocalStorage</strong> is similar to <strong class="source-inline">SessionStorage</strong>  in capabilities and data storage. It has the same interface and is  restricted also to the same origin of the page. The main difference is  that it persists beyond the life of the page and is shared among all the  open pages of the same origin. Websites and applications can use it to  store data and retrieve it throughout multiple sessions on the <span class="No-Break">same browser.</span></p>  			<p><strong class="source-inline">SessionStorage</strong> and <strong class="source-inline">LocalStorage</strong> share the <span class="No-Break">same interface:</span></p>  			<ul>  				<li><strong class="source-inline">.setItem(item_name, item_data)</strong>: Here, <strong class="source-inline">item_name</strong> is a string that uniquely identifies <strong class="source-inline">item_data</strong>, which is also <span class="No-Break">a string</span></li>  				<li><strong class="source-inline">.getItem(item_name)</strong>: Retrieves the string data stored under <strong class="source-inline">item-_name</strong>, or null if <span class="No-Break">not found</span></li>  				<li><strong class="source-inline">.removeItem(item_name)</strong>: Deletes the data by <strong class="source-inline">item_name</strong> from <span class="No-Break">the store</span></li>  				<li><strong class="source-inline">.clear()</strong>: Removes all data from <span class="No-Break">the store</span></li>  			</ul>  			<p>The preceding methods represent the totality of API endpoints  for both storages. Simple enough—we can serialize data to record it in  these stores. For example, to store a JSON object, we would use the  following (we can omit the <strong class="source-inline">window</strong> object reference, as it is considered a <span class="No-Break">global object):</span></p>  			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code">  localStorage.setItem("MyData", JSON.stringify({…});</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div>  			<p>And then, to retrieve it, we would use <span class="No-Break">the following:</span></p>  			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code">  let data=localStorage.getItem("MyData")  if(data){  &nbsp;&nbsp;&nbsp;data=JSON.parse(data);  }</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div>  			<p>Both stores have some limitations and a <span class="No-Break">few caveats:</span></p>  			<ul>  				<li>There is no standard limit set among browsers  for how many characters each store can hold. Strings are stored in  UTF-16, so each character can take from 2 bytes or more (see <a href="https://en.wikipedia.org/wiki/UTF-16">https://en.wikipedia.org/wiki/UTF-16</a>), which makes calculation hard. The specifications recommend at least 5 MB for <span class="No-Break">each storage.</span></li>  				<li>When these storages run out of space, some browsers crash the page, while others prompt the user for consent to expand <span class="No-Break">the storage.</span></li>  				<li>Access to store and retrieve data is sequential, possibly  blocking the render process and making the page/application look  irresponsive... But this only happens in <span class="No-Break">long operations.</span></li>  				<li>For <strong class="source-inline">sessionStorage</strong>, duplicating tabs will also duplicate the storage. Instead, for <strong class="source-inline">localStorage</strong>, both tabs will access the <span class="No-Break">same information.</span></li>  				<li>Neither localStorage nor sessionStorage is reactive or provides listeners to watch when a <span class="No-Break">value changes.</span></li>  			</ul>  			<p>The preceding limitations are in no way a threat or a suggestion not to use them. Instead, they  are the boundaries and limits to using them, since all data is stored  locally on the user’s browser, and nothing is sent back to the server  (as <span class="No-Break">cookies do).</span></p>  			<p>In contrast to these web storage objects, <strong class="source-inline">IndexedDB</strong> is a different system altogether. It is a full implementation  of a transactional database that stores JavaScript objects under a  unique key. We can open multiple databases, create connections to them,  and define schemas, and all operations are asynchronous, so there is no  application blocking. The size limit has also  been extended, with a soft limit of 50 MB. If a database grows more  than that, the user is prompted to consent to expand it, and more space  is given. In theory, depending on the implementation in each browser, it  could occupy as much space as available. In practice, each browser has  its own way to negotiate available space with the local operating  system, so no hard number can be given about its limits that would hold  true in <span class="No-Break">every case.</span></p>  			<p class="callout-heading">Curiosity</p>  			<p class="callout">The Chrome engine provides a flag to build the engine without limits to <strong class="source-inline">IndexedDB</strong>,  save for the available disk space. This flag can also be activated in  hybrid frameworks such as NW.js or when building the browser <span class="No-Break">from source.</span></p>  			<p>There is a major issue with <strong class="source-inline">IndexedDB</strong>, which is that its API is complicated and cumbersome, so it is very rare that an application would access it directly. Instead, since <strong class="source-inline">IndexedDB</strong> is so flexible and fast, there is a fair  number of libraries that create their own database implementation on  top of it or facilitate a simpler interface (using the Façade pattern,  for example). A curated list of these libraries and frameworks can be found in the <strong class="bold">Mozilla Developer Network</strong> documentation (https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API#see_also). In our implementation examples for <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_08.xhtml#_idTextAnchor186"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Multithreading with Web Workers</em>,  we will use one of these libraries. For the purposes of this chapter,  just keep in mind that each browser provides you with a powerful  database for your application, and you can access it through a variety  of patterns <span class="No-Break">and approaches.</span></p>  			<h1>Experimenting with reactivity and Proxies patterns</h1>  			<p>It is time to put into practice what we have learned in this chapter under the light of patterns we saw in <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_02.xhtml#_idTextAnchor040"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Software Design Principles and Patterns</em>, with a small experimental project. We want to create an option to make <strong class="source-inline">sessionStorage</strong>  data behave like a reactive central state manager so that we can use it  in our components. Possible uses for this approach could be to persist  user-entered data during refreshes, alert components of data changes,  and <span class="No-Break">so on.</span></p>  			<p>Since <strong class="source-inline">SessionStorage</strong> does  not provide an API we can listen to, our approach will be to create a  Proxy handler using the Decorator pattern, to match and keep  synchronized the values in the store with an internal and private  reactive property. We will wrap this in a <em class="italic">singleton</em> and use the <em class="italic">Central State </em>manager approach to share it in our application. Let’s start by creating our <span class="No-Break">core service:</span></p>  			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/services/sessionStorage.js</p>  			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code">  import { reactive } from 'vue';  let <strong class="bold">handler </strong>= {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1  <strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;props: reactive({})</strong>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2  <strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;get</strong>(target, prop, receiver) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let value = target[prop]  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (value instanceof Function) {  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (...args) =&gt; {  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return target[prop](...args)  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value = target.getItem(prop)  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (value) {  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.props[prop] = value;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.props[prop]  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}  &nbsp;&nbsp;&nbsp;&nbsp;},  <strong class="bold">&nbsp;&nbsp;&nbsp;&nbsp;set</strong>(target, prop, value) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//4  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target.setItem(prop, value)  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.props[prop] = value  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;  &nbsp;&nbsp;&nbsp;&nbsp;}  }  const Decorator= new Proxy(window.sessionStorage,&nbsp;handler);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//5  function <strong class="bold">useSessionStorage</strong>(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//6  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Decorator;  }  export { useSessionStorage }</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div>  			<p>In this <strong class="source-inline">service</strong> module, we will use the native JavaScript implementation of a <strong class="source-inline">Proxy</strong> object to capture specific calls to the API of the <strong class="source-inline">window.sessionStorage</strong> object. The use of Proxy objects is rather advanced in JavaScript, so I recommend that you look at the documentation on MDN here: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a>. We start by importing the <strong class="source-inline">reactive()</strong> constructor from Vue and then creating a plain object named <strong class="source-inline">handler</strong> (line <strong class="source-inline">//1</strong>), that will act as our proxy/decorator. This object will be placed to intercept the calls to the original <strong class="source-inline">sessionStorage</strong>. Inside it, we declare a <strong class="source-inline">prop</strong> property as reactive (line <strong class="source-inline">//2)</strong>),  initializing it with an empty object. This object will be synchronized  with the storage. Then, we create two traps (or interceptors): one for  get or read operations (line <strong class="source-inline">//3</strong>), and another for set or write operations (<span class="No-Break">line </span><span class="No-Break"><strong class="source-inline">//4</strong></span><span class="No-Break">).</span></p>  			<p>The <strong class="source-inline">get()</strong> function receives three arguments, of which we will use only two. The target refers to <strong class="source-inline">sessionStorage</strong>, and <strong class="source-inline">prop</strong> is the name of the method or attribute requested. Because <strong class="source-inline">prop</strong> can be either one, we test if it is a function with an <strong class="source-inline">if</strong>  statement, and if so, we return a function that takes in all the  arguments and returns the original function call with them. If it is not  a function, then we retrieve the item from the store, test if it is  part of our internal reactive property, and finally, return the value.  This makes sure that our internal <strong class="source-inline">props</strong> object is in sync with values created before the decorator <span class="No-Break">was implemented.</span></p>  			<p>The <strong class="source-inline">set()</strong> function is simpler, as we just take the value passed and store it in both places: our internal props and <span class="No-Break">the store.</span></p>  			<p>With our handler ready, in line <strong class="source-inline">//5</strong>, we create a <strong class="source-inline">Decorator</strong> proxy object using a native JavaScript constructor and provide a <strong class="source-inline">useSessionStorage()</strong> function in line <strong class="source-inline">//6</strong> so that we can export it as <span class="No-Break">a singleton.</span></p>  			<p>With our Decorator created, now we can use it in our components, with the same approach as is standard in <span class="No-Break">Vue 3:</span></p>  			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/session_storage/ChildSession.vue</p>  			<div data-testid="custom pre block" class="orm-ChapterReader-codeSnippetContainer"><pre class="source-code">  &lt;script setup&gt;  &nbsp;&nbsp;&nbsp;&nbsp;import {<strong class="bold">useSessionStorage</strong>} from "../../services/SessionStorage"  &nbsp;&nbsp;&nbsp;&nbsp;const <strong class="bold">$sessionStorage </strong>= <strong class="bold">useSessionStorage()</strong>  &lt;/script&gt;  &lt;template&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&lt;strong&gt;Child Component&lt;/strong&gt;  &nbsp;&nbsp;&nbsp;&nbsp;Counter: {{ <strong class="bold">$sessionStorage.counter </strong>}}  &lt;/template&gt;</pre><div class="orm-ChapterReader-snippetButtonContainer"></div></div>  			<p>Notice that now we can use this object as a Pinia store or a simple reactive object, and the value of <strong class="source-inline">sessionStorage</strong>  will always be synchronized and persist even if we refresh the page. To  view the full example, please check the implementation of the code  example in the GitHub repository. When you run it, you will see a  section like <span class="No-Break">this one:</span></p>  			<div>  				<div id="_idContainer054" class="IMG---Figure">  					<img src="Chapter%20777%20Data%20Flow%20Management%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_7.06_B18602.jpg" alt="Figure 7.6 – Example of our reactive $sessionStorage object" width="650" height="152">  				</div>  			</div>  			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Example of our reactive $sessionStorage object</p>  			<p>In this example, we also implemented a parent component with an  input element. When you modify the value, it is automatically  synchronized and reflected in the children component, but also in <strong class="source-inline">sessionStorage</strong>. If you open the browser’s developer tools and navigate to the <strong class="bold">Web Storage</strong> section, you will see this reflected. Here is a screenshot of how this looks in Chrome, on an <span class="No-Break">Ubuntu system:</span></p>  			<div>  				<div id="_idContainer055" class="IMG---Figure">  					<img src="Chapter%20777%20Data%20Flow%20Management%20Vue.js%203%20Design%20Patterns%20and%20Best%20Practices_files/Figure_7.07_B18602.jpg" alt="Figure 7.7 – Session Storage showing the item from the example" width="850" height="135">  				</div>  			</div>  			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – Session Storage showing the item from the example</p>  			<p>In the same way we implemented this pattern for the session storage, we could also, with a few changes, apply it to <span class="No-Break">local storage.</span></p>  			<h1>Summary</h1>  			<p>In this chapter, we have seen in detail the different approaches  and methods to control the flow of data between our components,  services, and persistent storage provided by modern browsers. We also  took time to integrate our knowledge by experimenting with session  storage and the Decorator pattern to create a reactive/persistent  central state. We took time to differentiate between approaches, and we  have seen code for the implementation of each method. All these new  skills are used daily in the development of Vue <span class="No-Break">3 applications.</span></p>  			<p>In the next chapter, we will investigate improving the performance of our application by using advanced JavaScript tools: <span class="No-Break">web workers.</span></p>  			<h1>Review questions</h1>  			<p>Use these questions to review what you have learned in <span class="No-Break">this chapter:</span></p>  			<ul>  				<li>Which methods do we have available to share data between <span class="No-Break">sibling components?</span></li>  				<li>What is a message/event bus, and when is it <span class="No-Break">most useful?</span></li>  				<li>What is a central state management approach, and how can we <span class="No-Break">implement it?</span></li>  				<li>What is the difference between session and <span class="No-Break">local storage?</span></li>  				<li>How can we see what information is stored in session or <span class="No-Break">local storage?</span></li>  			</ul> 