# Полезные советы

::: details Какие есть хорошие библиотеки для работы с ...?

### Карусель или слайдер

[Keen-Slider](https://keen-slider.io/), [Embla Carousel](https://www.embla-carousel.com/), [Splide](https://splidejs.com/)

Хорошо известный [Swiper](https://swiperjs.com/) не очень подходит для Vue.js

### Дата и время

[day.js](https://day.js.org/), [day-fnc.js](https://date-fns.org/)

Известный [moment.js](https://momentjs.com/) безвозвратно устарел.

::: tip
Современный JavaScript - это гораздо больше, чем было 10 лет назад. В 95% случаев для операций с датой достаточно возможностей стандартного пакета JavaScript `Intl`
:::

::: details Как поймать момент когда пользователь доскролил до определенного места?

Intersection Observer

:::

<!-- В тройке есть только один кейс протекания. -->
<!-- Когда классы корневого элемента компонента совпадают с классами родителя. -->

::: details i18n - интернационализация приложения

NPM библиотека для интернационализации и локализации i18n очень популярна, однако за последние годы она сильно располнела. В ней много возможностей для локализации дат, чисел, установки нужных склонений, поддержки RTL языков, загрузки локалей с сервера и кучи еще чего. На сайте i18next она называется уже даже "интернационализационным фреймворком".

В то же время часто для локализации сайта в большинстве случаев требуются очень простые вещи, занимающие всего пару процентов от всего функционала тяжеловеса i18n.

По сути обычно нужна реактивная функция, по ключу и текущей локали возвращающая строку.

Вариант реализации через композабл - в [этой статье](https://habr.com/ru/articles/736530/)

Ваш бандл "похудеет" на 50Кб.
:::

::: details Options API или Composition API?

Советуется Composition API (script setup) как более логичный и удобный, в котором программист контролирует поток выполнения программы средствами JavaScript, а не просто задает какие-то магические опции.

:::

::: details Ref или Reactive?

Отличие в плане использования - Reactive работает только с объектами и не отслеживает замену объекта. Ref работает со всем и отслеживает замену переменной:

```js
const a = Ref(1);
const b = Reactive({ x: 1 });

// is OK
a.value = 2;

// is NOT OK
b = { x: 2 };
```

Реализации реактивных переменных в Vue 2 и Vue 3 отличаются. Во Vue 2 была своя (фреймворка) реализация отслеживания изменений. Во Vue 3 для этого используется объект Proxy, введенный в ES6. Из-за поддержки данного функционала на уровне языка (JavaScript engine), соответствующий код фреймворка получается эффективней и проще.

Reactive непосредственно использует Proxy объект.

Ref на объекте использует напрямую Reactive для отслеживания изменения внутри объекта, и создает и хранит массив зависимостей переменной для примитивов и объектов в случае их замены.

Если хотите претенциозной эффективности - используйте на объектах Reactive, на примитивах - Ref. В ином случае можно все делать через Ref.

:::

::: details Когда использовать Provide/Inject?

### Use cases

- Настройки темы или конфигурации: Вы можете предоставить глобальные настройки, темы или параметры конфигурации на корневом уровне вашего приложения Vue.js и внедрить их в любой компонент, которому они нужны.

- Данные аутентификации: Предоставляйте информацию об аутентификации пользователя, например данные пользователя или токены аутентификации, компонентам, которым они необходимы, не передавая их через пропсы.

- Интернационализация (i18n): Храните данные перевода на корневом уровне и внедряйте их в компоненты, которым требуется отображать текст на разных языках.

- Тесно связанные компоненты: Например, компонент AccordianPanel, который всегда появляется только внутри слота компонента Accordian. Вы можете инжектировать общие данные, к которым вы всегда хотите иметь доступ, без необходимости передавать их в качестве пропсов.

### Лучшие практики и соображения

При использовании provide и inject необходимо помнить о нескольких лучших практиках:

- Избегайте чрезмерного использования: Хотя provide и inject могут быть очень мощными, не стоит ими злоупотреблять. Оставьте их для случаев, когда вам действительно нужно поделиться данными между компонентами, не создавая тесной связи между ними.

- Четкая документация: Документируйте данные, которые вы провайдите и инжектируете, чтобы разработчикам было легко понять, как взаимодействуют компоненты. Их также можно типизировать, - подробности в [официальной документации](https://vuejs.org/guide/typescript/composition-api.html#typing-provide-inject).

- Рассмотрите возможность Prop Drilling: Prop drilling обычно является антипаттерном, но в некоторых случаях передача данных через пропсы может быть более простым и прозрачным подходом. Оцените, являются ли provide и inject лучшим решением для вашего конкретного сценария.

:::
::: details ShallowRef

Когда у вас массив с большим количеством элементов, но данные внутри элементов массива не меняются, а может меняться только сам массив (добавление элементов, удаление, замена массива) - используйте `ShallowRef`.

Он работает как `Ref`, но не отслеживает изменения внутри элементов массива, что дает значительное улучшение производительности.

:::

::: details Миксины

Нужно забыть о них как о страшном сне. Миксины как паттерн множественного наследования являются очень плохой архитектурной практикой и должны быть избегаемы. Во Vue 2 в самом фреймворке не было возможности сделать для компонент общей часть стейта и методов, поэтому использовались миксины. Во Vue 3 появилось Composition API и миксины стали не нужны.

:::

::: details Pug и Stylus
Во Vue экосистеме (включая средства разработки и расширения) данные техноологии плохо поддерживаются и не рекомендуются к использованию.
:::

::: details Chrome DevTools custom formatters

Google Chrome  и некоторые основанные на Chromium браузеры имеют настройку в DevTools в разделе настроек Console - "Enable custom formatters". После её включения реактивные объекты будут показываться в консоли и в попап-ах при дебаге в более читаемом виде:

![image](/images/faq/chrome-formatter-1.jpg)

вместо стандартного:

![image](/images/faq/chrome-formatter-2.jpg)

Временно отключить программно настройку можно так:

```js
const old = window.devtoolsFormatters;
delete window.devtoolsFormatters;
// will print out data without custom formatting
console.log(obj);
window.devtoolsFormatters = old;
```

:::
